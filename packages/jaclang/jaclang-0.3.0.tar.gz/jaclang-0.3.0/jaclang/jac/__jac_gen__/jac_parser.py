# The file was automatically generated by Lark v1.1.8
__version__ = "1.1.8"

#
#
#   Lark Stand-alone Generator Tool
# ----------------------------------
# Generates a stand-alone LALR(1) parser
#
# Git:    https://github.com/erezsh/lark
# Author: Erez Shinan (erezshin@gmail.com)
#
#
#    >>> LICENSE
#
#    This tool and its generated code use a separate license from Lark,
#    and are subject to the terms of the Mozilla Public License, v. 2.0.
#    If a copy of the MPL was not distributed with this
#    file, You can obtain one at https://mozilla.org/MPL/2.0/.
#
#    If you wish to purchase a commercial license for this tool and its
#    generated code, you may contact me via email or otherwise.
#
#    If MPL2 is incompatible with your free or open-source project,
#    contact me and we'll work it out.
#
#

from copy import deepcopy
from abc import ABC, abstractmethod
from types import ModuleType
from typing import (
    TypeVar,
    Generic,
    Type,
    Tuple,
    List,
    Dict,
    Iterator,
    Collection,
    Callable,
    Optional,
    FrozenSet,
    Any,
    Union,
    Iterable,
    IO,
    TYPE_CHECKING,
    overload,
    Sequence,
    Pattern as REPattern,
    ClassVar,
    Set,
    Mapping,
)




class LarkError(Exception):
    pass


class ConfigurationError(LarkError, ValueError):
    pass


def assert_config(value, options: Collection, msg="Got %r, expected one of %s"):
    if value not in options:
        raise ConfigurationError(msg % (value, options))


class GrammarError(LarkError):
    pass


class ParseError(LarkError):
    pass


class LexError(LarkError):
    pass


T = TypeVar("T")


class UnexpectedInput(LarkError):
    #--

    line: int
    column: int
    pos_in_stream = None
    state: Any
    _terminals_by_name = None
    interactive_parser: "InteractiveParser"

    def get_context(self, text: str, span: int = 40) -> str:
        #--
        assert self.pos_in_stream is not None, self
        pos = self.pos_in_stream
        start = max(pos - span, 0)
        end = pos + span
        if not isinstance(text, bytes):
            before = text[start:pos].rsplit("\n", 1)[-1]
            after = text[pos:end].split("\n", 1)[0]
            return before + after + "\n" + " " * len(before.expandtabs()) + "^\n"
        else:
            before = text[start:pos].rsplit(b"\n", 1)[-1]
            after = text[pos:end].split(b"\n", 1)[0]
            return (
                before + after + b"\n" + b" " * len(before.expandtabs()) + b"^\n"
            ).decode("ascii", "backslashreplace")

    def match_examples(
        self,
        parse_fn: "Callable[[str], Tree]",
        examples: Union[Mapping[T, Iterable[str]], Iterable[Tuple[T, Iterable[str]]]],
        token_type_match_fallback: bool = False,
        use_accepts: bool = True,
    ) -> Optional[T]:
        #--
        assert self.state is not None, "Not supported for this exception"

        if isinstance(examples, Mapping):
            examples = examples.items()

        candidate = (None, False)
        for i, (label, example) in enumerate(examples):
            assert not isinstance(example, str), "Expecting a list"

            for j, malformed in enumerate(example):
                try:
                    parse_fn(malformed)
                except UnexpectedInput as ut:
                    if ut.state == self.state:
                        if (
                            use_accepts
                            and isinstance(self, UnexpectedToken)
                            and isinstance(ut, UnexpectedToken)
                            and ut.accepts != self.accepts
                        ):
                            logger.debug(
                                "Different accepts with same state[%d]: %s != %s at example [%s][%s]"
                                % (self.state, self.accepts, ut.accepts, i, j)
                            )
                            continue
                        if isinstance(
                            self, (UnexpectedToken, UnexpectedEOF)
                        ) and isinstance(ut, (UnexpectedToken, UnexpectedEOF)):
                            if ut.token == self.token:  ##

                                logger.debug("Exact Match at example [%s][%s]" % (i, j))
                                return label

                            if token_type_match_fallback:
                                ##

                                if (ut.token.type == self.token.type) and not candidate[
                                    -1
                                ]:
                                    logger.debug(
                                        "Token Type Fallback at example [%s][%s]"
                                        % (i, j)
                                    )
                                    candidate = label, True

                        if candidate[0] is None:
                            logger.debug(
                                "Same State match at example [%s][%s]" % (i, j)
                            )
                            candidate = label, False

        return candidate[0]

    def _format_expected(self, expected):
        if self._terminals_by_name:
            d = self._terminals_by_name
            expected = [
                d[t_name].user_repr() if t_name in d else t_name for t_name in expected
            ]
        return "Expected one of: \n\t* %s\n" % "\n\t* ".join(expected)


class UnexpectedEOF(ParseError, UnexpectedInput):
    #--

    expected: "List[Token]"

    def __init__(self, expected, state=None, terminals_by_name=None):
        super(UnexpectedEOF, self).__init__()

        self.expected = expected
        self.state = state
        from .lexer import Token

        self.token = Token("<EOF>", "")  ##

        self.pos_in_stream = -1
        self.line = -1
        self.column = -1
        self._terminals_by_name = terminals_by_name

    def __str__(self):
        message = "Unexpected end-of-input. "
        message += self._format_expected(self.expected)
        return message


class UnexpectedCharacters(LexError, UnexpectedInput):
    #--

    allowed: Set[str]
    considered_tokens: Set[Any]

    def __init__(
        self,
        seq,
        lex_pos,
        line,
        column,
        allowed=None,
        considered_tokens=None,
        state=None,
        token_history=None,
        terminals_by_name=None,
        considered_rules=None,
    ):
        super(UnexpectedCharacters, self).__init__()

        ##

        self.line = line
        self.column = column
        self.pos_in_stream = lex_pos
        self.state = state
        self._terminals_by_name = terminals_by_name

        self.allowed = allowed
        self.considered_tokens = considered_tokens
        self.considered_rules = considered_rules
        self.token_history = token_history

        if isinstance(seq, bytes):
            self.char = seq[lex_pos : lex_pos + 1].decode("ascii", "backslashreplace")
        else:
            self.char = seq[lex_pos]
        self._context = self.get_context(seq)

    def __str__(self):
        message = (
            "No terminal matches '%s' in the current parser context, at line %d col %d"
            % (self.char, self.line, self.column)
        )
        message += "\n\n" + self._context
        if self.allowed:
            message += self._format_expected(self.allowed)
        if self.token_history:
            message += "\nPrevious tokens: %s\n" % ", ".join(
                repr(t) for t in self.token_history
            )
        return message


class UnexpectedToken(ParseError, UnexpectedInput):
    #--

    expected: Set[str]
    considered_rules: Set[str]

    def __init__(
        self,
        token,
        expected,
        considered_rules=None,
        state=None,
        interactive_parser=None,
        terminals_by_name=None,
        token_history=None,
    ):
        super(UnexpectedToken, self).__init__()

        ##

        self.line = getattr(token, "line", "?")
        self.column = getattr(token, "column", "?")
        self.pos_in_stream = getattr(token, "start_pos", None)
        self.state = state

        self.token = token
        self.expected = expected  ##

        self._accepts = NO_VALUE
        self.considered_rules = considered_rules
        self.interactive_parser = interactive_parser
        self._terminals_by_name = terminals_by_name
        self.token_history = token_history

    @property
    def accepts(self) -> Set[str]:
        if self._accepts is NO_VALUE:
            self._accepts = (
                self.interactive_parser and self.interactive_parser.accepts()
            )
        return self._accepts

    def __str__(self):
        message = "Unexpected token %r at line %s, column %s.\n%s" % (
            self.token,
            self.line,
            self.column,
            self._format_expected(self.accepts or self.expected),
        )
        if self.token_history:
            message += "Previous tokens: %r\n" % self.token_history

        return message


class VisitError(LarkError):
    #--

    obj: "Union[Tree, Token]"
    orig_exc: Exception

    def __init__(self, rule, obj, orig_exc):
        message = 'Error trying to process rule "%s":\n\n%s' % (rule, orig_exc)
        super(VisitError, self).__init__(message)

        self.rule = rule
        self.obj = obj
        self.orig_exc = orig_exc


class MissingVariableError(LarkError):
    pass



import sys, re
import logging

logger: logging.Logger = logging.getLogger("lark")
logger.addHandler(logging.StreamHandler())
##

##

logger.setLevel(logging.CRITICAL)


NO_VALUE = object()

T = TypeVar("T")


def classify(
    seq: Iterable, key: Optional[Callable] = None, value: Optional[Callable] = None
) -> Dict:
    d: Dict[Any, Any] = {}
    for item in seq:
        k = key(item) if (key is not None) else item
        v = value(item) if (value is not None) else item
        try:
            d[k].append(v)
        except KeyError:
            d[k] = [v]
    return d


def _deserialize(data: Any, namespace: Dict[str, Any], memo: Dict) -> Any:
    if isinstance(data, dict):
        if "__type__" in data:  ##

            class_ = namespace[data["__type__"]]
            return class_.deserialize(data, memo)
        elif "@" in data:
            return memo[data["@"]]
        return {
            key: _deserialize(value, namespace, memo) for key, value in data.items()
        }
    elif isinstance(data, list):
        return [_deserialize(value, namespace, memo) for value in data]
    return data


_T = TypeVar("_T", bound="Serialize")


class Serialize:
    #--

    def memo_serialize(self, types_to_memoize: List) -> Any:
        memo = SerializeMemoizer(types_to_memoize)
        return self.serialize(memo), memo.serialize()

    def serialize(self, memo=None) -> Dict[str, Any]:
        if memo and memo.in_types(self):
            return {"@": memo.memoized.get(self)}

        fields = getattr(self, "__serialize_fields__")
        res = {f: _serialize(getattr(self, f), memo) for f in fields}
        res["__type__"] = type(self).__name__
        if hasattr(self, "_serialize"):
            self._serialize(res, memo)  ##

        return res

    @classmethod
    def deserialize(cls: Type[_T], data: Dict[str, Any], memo: Dict[int, Any]) -> _T:
        namespace = getattr(cls, "__serialize_namespace__", [])
        namespace = {c.__name__: c for c in namespace}

        fields = getattr(cls, "__serialize_fields__")

        if "@" in data:
            return memo[data["@"]]

        inst = cls.__new__(cls)
        for f in fields:
            try:
                setattr(inst, f, _deserialize(data[f], namespace, memo))
            except KeyError as e:
                raise KeyError("Cannot find key for class", cls, e)

        if hasattr(inst, "_deserialize"):
            inst._deserialize()  ##


        return inst


class SerializeMemoizer(Serialize):
    #--

    __serialize_fields__ = ("memoized",)

    def __init__(self, types_to_memoize: List) -> None:
        self.types_to_memoize = tuple(types_to_memoize)
        self.memoized = Enumerator()

    def in_types(self, value: Serialize) -> bool:
        return isinstance(value, self.types_to_memoize)

    def serialize(self) -> Dict[int, Any]:  ##

        return _serialize(self.memoized.reversed(), None)

    @classmethod
    def deserialize(cls, data: Dict[int, Any], namespace: Dict[str, Any], memo: Dict[Any, Any]) -> Dict[int, Any]:  ##

        return _deserialize(data, namespace, memo)


try:
    import regex

    _has_regex = True
except ImportError:
    _has_regex = False

if sys.version_info >= (3, 11):
    import re._parser as sre_parse
    import re._constants as sre_constants
else:
    import sre_parse
    import sre_constants

categ_pattern = re.compile(r"\\p{[A-Za-z_]+}")


def get_regexp_width(expr: str) -> Union[Tuple[int, int], List[int]]:
    if _has_regex:
        ##

        ##

        ##

        regexp_final = re.sub(categ_pattern, "A", expr)
    else:
        if re.search(categ_pattern, expr):
            raise ImportError(
                "`regex` module must be installed in order to use Unicode categories.",
                expr,
            )
        regexp_final = expr
    try:
        ##

        return [int(x) for x in sre_parse.parse(regexp_final).getwidth()]  ##

    except sre_constants.error:
        if not _has_regex:
            raise ValueError(expr)
        else:
            ##

            ##

            c = regex.compile(regexp_final)
            if c.match("") is None:
                ##

                return 1, int(sre_constants.MAXREPEAT)
            else:
                return 0, int(sre_constants.MAXREPEAT)



from collections import OrderedDict


class Meta:
    empty: bool
    line: int
    column: int
    start_pos: int
    end_line: int
    end_column: int
    end_pos: int
    orig_expansion: "List[TerminalDef]"
    match_tree: bool

    def __init__(self):
        self.empty = True


_Leaf_T = TypeVar("_Leaf_T")
Branch = Union[_Leaf_T, "Tree[_Leaf_T]"]


class Tree(Generic[_Leaf_T]):
    #--

    data: str
    children: "List[Branch[_Leaf_T]]"

    def __init__(
        self, data: str, children: "List[Branch[_Leaf_T]]", meta: Optional[Meta] = None
    ) -> None:
        self.data = data
        self.children = children
        self._meta = meta

    @property
    def meta(self) -> Meta:
        if self._meta is None:
            self._meta = Meta()
        return self._meta

    def __repr__(self):
        return "Tree(%r, %r)" % (self.data, self.children)

    def _pretty_label(self):
        return self.data

    def _pretty(self, level, indent_str):
        yield f"{indent_str*level}{self._pretty_label()}"
        if len(self.children) == 1 and not isinstance(self.children[0], Tree):
            yield f"\t{self.children[0]}\n"
        else:
            yield "\n"
            for n in self.children:
                if isinstance(n, Tree):
                    yield from n._pretty(level + 1, indent_str)
                else:
                    yield f"{indent_str*(level+1)}{n}\n"

    def pretty(self, indent_str: str = "  ") -> str:
        #--
        return "".join(self._pretty(0, indent_str))

    def __rich__(self, parent: Optional["rich.tree.Tree"] = None) -> "rich.tree.Tree":
        #--
        return self._rich(parent)

    def _rich(self, parent):
        if parent:
            tree = parent.add(f"[bold]{self.data}[/bold]")
        else:
            import rich.tree

            tree = rich.tree.Tree(self.data)

        for c in self.children:
            if isinstance(c, Tree):
                c._rich(tree)
            else:
                tree.add(f"[green]{c}[/green]")

        return tree

    def __eq__(self, other):
        try:
            return self.data == other.data and self.children == other.children
        except AttributeError:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self) -> int:
        return hash((self.data, tuple(self.children)))

    def iter_subtrees(self) -> "Iterator[Tree[_Leaf_T]]":
        #--
        queue = [self]
        subtrees = OrderedDict()
        for subtree in queue:
            subtrees[id(subtree)] = subtree
            ##

            queue += [
                c
                for c in reversed(subtree.children)  ##

                if isinstance(c, Tree) and id(c) not in subtrees
            ]

        del queue
        return reversed(list(subtrees.values()))

    def iter_subtrees_topdown(self):
        #--
        stack = [self]
        stack_append = stack.append
        stack_pop = stack.pop
        while stack:
            node = stack_pop()
            if not isinstance(node, Tree):
                continue
            yield node
            for child in reversed(node.children):
                stack_append(child)

    def find_pred(
        self, pred: "Callable[[Tree[_Leaf_T]], bool]"
    ) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return filter(pred, self.iter_subtrees())

    def find_data(self, data: str) -> "Iterator[Tree[_Leaf_T]]":
        #--
        return self.find_pred(lambda t: t.data == data)


from functools import wraps, update_wrapper
from inspect import getmembers, getmro

_Return_T = TypeVar("_Return_T")
_Return_V = TypeVar("_Return_V")
_Leaf_T = TypeVar("_Leaf_T")
_Leaf_U = TypeVar("_Leaf_U")
_R = TypeVar("_R")
_FUNC = Callable[..., _Return_T]
_DECORATED = Union[_FUNC, type]


class _DiscardType:
    #--

    def __repr__(self):
        return "lark.visitors.Discard"


Discard = _DiscardType()

##



class _Decoratable:
    #--

    @classmethod
    def _apply_v_args(cls, visit_wrapper):
        mro = getmro(cls)
        assert mro[0] is cls
        libmembers = {name for _cls in mro[1:] for name, _ in getmembers(_cls)}
        for name, value in getmembers(cls):
            ##

            if name.startswith("_") or (
                name in libmembers and name not in cls.__dict__
            ):
                continue
            if not callable(value):
                continue

            ##

            if isinstance(cls.__dict__[name], _VArgsWrapper):
                continue

            setattr(cls, name, _VArgsWrapper(cls.__dict__[name], visit_wrapper))
        return cls

    def __class_getitem__(cls, _):
        return cls


class Transformer(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    __visit_tokens__ = True  ##


    def __init__(self, visit_tokens: bool = True) -> None:
        self.__visit_tokens__ = visit_tokens

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            try:
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    return f.visit_wrapper(f, tree.data, children, tree.meta)
                else:
                    return f(children)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(tree.data, tree, e)

    def _call_userfunc_token(self, token):
        try:
            f = getattr(self, token.type)
        except AttributeError:
            return self.__default_token__(token)
        else:
            try:
                return f(token)
            except GrammarError:
                raise
            except Exception as e:
                raise VisitError(token.type, token, e)

    def _transform_children(self, children):
        for c in children:
            if isinstance(c, Tree):
                res = self._transform_tree(c)
            elif self.__visit_tokens__ and isinstance(c, Token):
                res = self._call_userfunc_token(c)
            else:
                res = c

            if res is not Discard:
                yield res

    def _transform_tree(self, tree):
        children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree, children)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        #--
        return self._transform_tree(tree)

    def __mul__(
        self: "Transformer[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V,]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        #--
        return TransformerChain(self, other)

    def __default__(self, data, children, meta):
        #--
        return Tree(data, children, meta)

    def __default_token__(self, token):
        #--
        return token


def merge_transformers(base_transformer=None, **transformers_to_merge):
    #--
    if base_transformer is None:
        base_transformer = Transformer()
    for prefix, transformer in transformers_to_merge.items():
        for method_name in dir(transformer):
            method = getattr(transformer, method_name)
            if not callable(method):
                continue
            if method_name.startswith("_") or method_name == "transform":
                continue
            prefixed_method = prefix + "__" + method_name
            if hasattr(base_transformer, prefixed_method):
                raise AttributeError(
                    "Cannot merge: method '%s' appears more than once" % prefixed_method
                )

            setattr(base_transformer, prefixed_method, method)

    return base_transformer


class InlineTransformer(Transformer):  ##

    def _call_userfunc(self, tree, new_children=None):
        ##

        children = new_children if new_children is not None else tree.children
        try:
            f = getattr(self, tree.data)
        except AttributeError:
            return self.__default__(tree.data, children, tree.meta)
        else:
            return f(*children)


class TransformerChain(Generic[_Leaf_T, _Return_T]):
    transformers: "Tuple[Union[Transformer, TransformerChain], ...]"

    def __init__(self, *transformers: "Union[Transformer, TransformerChain]") -> None:
        self.transformers = transformers

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for t in self.transformers:
            tree = t.transform(tree)
        return cast(_Return_T, tree)

    def __mul__(
        self: "TransformerChain[_Leaf_T, Tree[_Leaf_U]]",
        other: "Union[Transformer[_Leaf_U, _Return_V], TransformerChain[_Leaf_U, _Return_V]]",
    ) -> "TransformerChain[_Leaf_T, _Return_V]":
        return TransformerChain(*self.transformers + (other,))


class Transformer_InPlace(Transformer[_Leaf_T, _Return_T]):
    #--

    def _transform_tree(self, tree):  ##

        return self._call_userfunc(tree)

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        for subtree in tree.iter_subtrees():
            subtree.children = list(self._transform_children(subtree.children))

        return self._transform_tree(tree)


class Transformer_NonRecursive(Transformer[_Leaf_T, _Return_T]):
    #--

    def transform(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        rev_postfix = []
        q: List[Branch[_Leaf_T]] = [tree]
        while q:
            t = q.pop()
            rev_postfix.append(t)
            if isinstance(t, Tree):
                q += t.children

        ##

        stack: List = []
        for x in reversed(rev_postfix):
            if isinstance(x, Tree):
                size = len(x.children)
                if size:
                    args = stack[-size:]
                    del stack[-size:]
                else:
                    args = []

                res = self._call_userfunc(x, args)
                if res is not Discard:
                    stack.append(res)

            elif self.__visit_tokens__ and isinstance(x, Token):
                res = self._call_userfunc_token(x)
                if res is not Discard:
                    stack.append(res)
            else:
                stack.append(x)

        (result,) = stack  ##

        ##

        ##

        ##

        return cast(_Return_T, result)


class Transformer_InPlaceRecursive(Transformer):
    #--

    def _transform_tree(self, tree):
        tree.children = list(self._transform_children(tree.children))
        return self._call_userfunc(tree)


##



class VisitorBase:
    def _call_userfunc(self, tree):
        return getattr(self, tree.data, self.__default__)(tree)

    def __default__(self, tree):
        #--
        return tree

    def __class_getitem__(cls, _):
        return cls


class Visitor(VisitorBase, ABC, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees():
            self._call_userfunc(subtree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for subtree in tree.iter_subtrees_topdown():
            self._call_userfunc(subtree)
        return tree


class Visitor_Recursive(VisitorBase, Generic[_Leaf_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        for child in tree.children:
            if isinstance(child, Tree):
                self.visit(child)

        self._call_userfunc(tree)
        return tree

    def visit_topdown(self, tree: Tree[_Leaf_T]) -> Tree[_Leaf_T]:
        #--
        self._call_userfunc(tree)

        for child in tree.children:
            if isinstance(child, Tree):
                self.visit_topdown(child)

        return tree


class Interpreter(_Decoratable, ABC, Generic[_Leaf_T, _Return_T]):
    #--

    def visit(self, tree: Tree[_Leaf_T]) -> _Return_T:
        ##

        ##

        ##

        return self._visit_tree(tree)

    def _visit_tree(self, tree: Tree[_Leaf_T]):
        f = getattr(self, tree.data)
        wrapper = getattr(f, "visit_wrapper", None)
        if wrapper is not None:
            return f.visit_wrapper(f, tree.data, tree.children, tree.meta)
        else:
            return f(tree)

    def visit_children(self, tree: Tree[_Leaf_T]) -> List:
        return [
            self._visit_tree(child) if isinstance(child, Tree) else child
            for child in tree.children
        ]

    def __getattr__(self, name):
        return self.__default__

    def __default__(self, tree):
        return self.visit_children(tree)


_InterMethod = Callable[[Type[Interpreter], _Return_T], _R]


def visit_children_decor(func: _InterMethod) -> _InterMethod:
    #--

    @wraps(func)
    def inner(cls, tree):
        values = cls.visit_children(tree)
        return func(cls, values)

    return inner


##



def _apply_v_args(obj, visit_wrapper):
    try:
        _apply = obj._apply_v_args
    except AttributeError:
        return _VArgsWrapper(obj, visit_wrapper)
    else:
        return _apply(visit_wrapper)


class _VArgsWrapper:
    #--

    base_func: Callable

    def __init__(
        self, func: Callable, visit_wrapper: Callable[[Callable, str, list, Any], Any]
    ):
        if isinstance(func, _VArgsWrapper):
            func = func.base_func
        ##

        self.base_func = func  ##

        self.visit_wrapper = visit_wrapper
        update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        return self.base_func(*args, **kwargs)

    def __get__(self, instance, owner=None):
        try:
            ##

            ##

            g = type(self.base_func).__get__
        except AttributeError:
            return self
        else:
            return _VArgsWrapper(g(self.base_func, instance, owner), self.visit_wrapper)

    def __set_name__(self, owner, name):
        try:
            f = type(self.base_func).__set_name__
        except AttributeError:
            return
        else:
            f(self.base_func, owner, name)


def _vargs_inline(f, _data, children, _meta):
    return f(*children)


def _vargs_meta_inline(f, _data, children, meta):
    return f(meta, *children)


def _vargs_meta(f, _data, children, meta):
    return f(meta, children)


def _vargs_tree(f, data, children, meta):
    return f(Tree(data, children, meta))


def v_args(
    inline: bool = False,
    meta: bool = False,
    tree: bool = False,
    wrapper: Optional[Callable] = None,
) -> Callable[[_DECORATED], _DECORATED]:
    #--
    if tree and (meta or inline):
        raise ValueError(
            "Visitor functions cannot combine 'tree' with 'meta' or 'inline'."
        )

    func = None
    if meta:
        if inline:
            func = _vargs_meta_inline
        else:
            func = _vargs_meta
    elif inline:
        func = _vargs_inline
    elif tree:
        func = _vargs_tree

    if wrapper is not None:
        if func is not None:
            raise ValueError(
                "Cannot use 'wrapper' along with 'tree', 'meta' or 'inline'."
            )
        func = wrapper

    def _visitor_args_dec(obj):
        return _apply_v_args(obj, func)

    return _visitor_args_dec



TOKEN_DEFAULT_PRIORITY = 0


class Symbol(Serialize):
    __slots__ = ("name",)

    name: str
    is_term: ClassVar[bool] = NotImplemented

    def __init__(self, name: str) -> None:
        self.name = name

    def __eq__(self, other):
        assert isinstance(other, Symbol), other
        return self.is_term == other.is_term and self.name == other.name

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.name)

    def __repr__(self):
        return "%s(%r)" % (type(self).__name__, self.name)

    fullrepr = property(__repr__)

    def renamed(self, f):
        return type(self)(f(self.name))


class Terminal(Symbol):
    __serialize_fields__ = "name", "filter_out"

    is_term: ClassVar[bool] = True

    def __init__(self, name, filter_out=False):
        self.name = name
        self.filter_out = filter_out

    @property
    def fullrepr(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.filter_out)

    def renamed(self, f):
        return type(self)(f(self.name), self.filter_out)


class NonTerminal(Symbol):
    __serialize_fields__ = ("name",)

    is_term: ClassVar[bool] = False


class RuleOptions(Serialize):
    __serialize_fields__ = (
        "keep_all_tokens",
        "expand1",
        "priority",
        "template_source",
        "empty_indices",
    )

    keep_all_tokens: bool
    expand1: bool
    priority: Optional[int]
    template_source: Optional[str]
    empty_indices: Tuple[bool, ...]

    def __init__(
        self,
        keep_all_tokens: bool = False,
        expand1: bool = False,
        priority: Optional[int] = None,
        template_source: Optional[str] = None,
        empty_indices: Tuple[bool, ...] = (),
    ) -> None:
        self.keep_all_tokens = keep_all_tokens
        self.expand1 = expand1
        self.priority = priority
        self.template_source = template_source
        self.empty_indices = empty_indices

    def __repr__(self):
        return "RuleOptions(%r, %r, %r, %r)" % (
            self.keep_all_tokens,
            self.expand1,
            self.priority,
            self.template_source,
        )


class Rule(Serialize):
    #--

    __slots__ = ("origin", "expansion", "alias", "options", "order", "_hash")

    __serialize_fields__ = "origin", "expansion", "order", "alias", "options"
    __serialize_namespace__ = Terminal, NonTerminal, RuleOptions

    origin: NonTerminal
    expansion: Sequence[Symbol]
    order: int
    alias: Optional[str]
    options: RuleOptions
    _hash: int

    def __init__(
        self,
        origin: NonTerminal,
        expansion: Sequence[Symbol],
        order: int = 0,
        alias: Optional[str] = None,
        options: Optional[RuleOptions] = None,
    ):
        self.origin = origin
        self.expansion = expansion
        self.alias = alias
        self.order = order
        self.options = options or RuleOptions()
        self._hash = hash((self.origin, tuple(self.expansion)))

    def _deserialize(self):
        self._hash = hash((self.origin, tuple(self.expansion)))

    def __str__(self):
        return "<%s : %s>" % (
            self.origin.name,
            " ".join(x.name for x in self.expansion),
        )

    def __repr__(self):
        return "Rule(%r, %r, %r, %r)" % (
            self.origin,
            self.expansion,
            self.alias,
            self.options,
        )

    def __hash__(self):
        return self._hash

    def __eq__(self, other):
        if not isinstance(other, Rule):
            return False
        return self.origin == other.origin and self.expansion == other.expansion



from copy import copy

try:  ##

    has_interegular = bool(interegular)
except NameError:
    has_interegular = False


class Pattern(Serialize, ABC):
    #--

    value: str
    flags: Collection[str]
    raw: Optional[str]
    type: ClassVar[str]

    def __init__(
        self, value: str, flags: Collection[str] = (), raw: Optional[str] = None
    ) -> None:
        self.value = value
        self.flags = frozenset(flags)
        self.raw = raw

    def __repr__(self):
        return repr(self.to_regexp())

    ##

    def __hash__(self):
        return hash((type(self), self.value, self.flags))

    def __eq__(self, other):
        return (
            type(self) == type(other)
            and self.value == other.value
            and self.flags == other.flags
        )

    @abstractmethod
    def to_regexp(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def min_width(self) -> int:
        raise NotImplementedError()

    @property
    @abstractmethod
    def max_width(self) -> int:
        raise NotImplementedError()

    def _get_flags(self, value):
        for f in self.flags:
            value = "(?%s:%s)" % (f, value)
        return value


class PatternStr(Pattern):
    __serialize_fields__ = "value", "flags", "raw"

    type: ClassVar[str] = "str"

    def to_regexp(self) -> str:
        return self._get_flags(re.escape(self.value))

    @property
    def min_width(self) -> int:
        return len(self.value)

    @property
    def max_width(self) -> int:
        return len(self.value)


class PatternRE(Pattern):
    __serialize_fields__ = "value", "flags", "raw", "_width"

    type: ClassVar[str] = "re"

    def to_regexp(self) -> str:
        return self._get_flags(self.value)

    _width = None

    def _get_width(self):
        if self._width is None:
            self._width = get_regexp_width(self.to_regexp())
        return self._width

    @property
    def min_width(self) -> int:
        return self._get_width()[0]

    @property
    def max_width(self) -> int:
        return self._get_width()[1]


class TerminalDef(Serialize):
    #--
    __serialize_fields__ = "name", "pattern", "priority"
    __serialize_namespace__ = PatternStr, PatternRE

    name: str
    pattern: Pattern
    priority: int

    def __init__(
        self, name: str, pattern: Pattern, priority: int = TOKEN_DEFAULT_PRIORITY
    ) -> None:
        assert isinstance(pattern, Pattern), pattern
        self.name = name
        self.pattern = pattern
        self.priority = priority

    def __repr__(self):
        return "%s(%r, %r)" % (type(self).__name__, self.name, self.pattern)

    def user_repr(self) -> str:
        if self.name.startswith("__"):  ##

            return self.pattern.raw or self.name
        else:
            return self.name


_T = TypeVar("_T", bound="Token")


class Token(str):
    #--

    __slots__ = (
        "type",
        "start_pos",
        "value",
        "line",
        "column",
        "end_line",
        "end_column",
        "end_pos",
    )

    __match_args__ = ("type", "value")

    type: str
    start_pos: Optional[int]
    value: Any
    line: Optional[int]
    column: Optional[int]
    end_line: Optional[int]
    end_column: Optional[int]
    end_pos: Optional[int]

    @overload
    def __new__(
        cls,
        type: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    @overload
    def __new__(
        cls,
        type_: str,
        value: Any,
        start_pos: Optional[int] = None,
        line: Optional[int] = None,
        column: Optional[int] = None,
        end_line: Optional[int] = None,
        end_column: Optional[int] = None,
        end_pos: Optional[int] = None,
    ) -> "Token":
        ...

    def __new__(cls, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return cls._future_new(*args, **kwargs)

    @classmethod
    def _future_new(
        cls,
        type,
        value,
        start_pos=None,
        line=None,
        column=None,
        end_line=None,
        end_column=None,
        end_pos=None,
    ):
        inst = super(Token, cls).__new__(cls, value)

        inst.type = type
        inst.start_pos = start_pos
        inst.value = value
        inst.line = line
        inst.column = column
        inst.end_line = end_line
        inst.end_column = end_column
        inst.end_pos = end_pos
        return inst

    @overload
    def update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    @overload
    def update(
        self, type_: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        ...

    def update(self, *args, **kwargs):
        if "type_" in kwargs:
            warnings.warn(
                "`type_` is deprecated use `type` instead", DeprecationWarning
            )

            if "type" in kwargs:
                raise TypeError(
                    "Error: using both 'type' and the deprecated 'type_' as arguments."
                )
            kwargs["type"] = kwargs.pop("type_")

        return self._future_update(*args, **kwargs)

    def _future_update(
        self, type: Optional[str] = None, value: Optional[Any] = None
    ) -> "Token":
        return Token.new_borrow_pos(
            type if type is not None else self.type,
            value if value is not None else self.value,
            self,
        )

    @classmethod
    def new_borrow_pos(cls: Type[_T], type_: str, value: Any, borrow_t: "Token") -> _T:
        return cls(
            type_,
            value,
            borrow_t.start_pos,
            borrow_t.line,
            borrow_t.column,
            borrow_t.end_line,
            borrow_t.end_column,
            borrow_t.end_pos,
        )

    def __reduce__(self):
        return (
            self.__class__,
            (self.type, self.value, self.start_pos, self.line, self.column),
        )

    def __repr__(self):
        return "Token(%r, %r)" % (self.type, self.value)

    def __deepcopy__(self, memo):
        return Token(self.type, self.value, self.start_pos, self.line, self.column)

    def __eq__(self, other):
        if isinstance(other, Token) and self.type != other.type:
            return False

        return str.__eq__(self, other)

    __hash__ = str.__hash__


class LineCounter:
    #--

    __slots__ = "char_pos", "line", "column", "line_start_pos", "newline_char"

    def __init__(self, newline_char):
        self.newline_char = newline_char
        self.char_pos = 0
        self.line = 1
        self.column = 1
        self.line_start_pos = 0

    def __eq__(self, other):
        if not isinstance(other, LineCounter):
            return NotImplemented

        return (
            self.char_pos == other.char_pos and self.newline_char == other.newline_char
        )

    def feed(self, token: Token, test_newline=True):
        #--
        if test_newline:
            newlines = token.count(self.newline_char)
            if newlines:
                self.line += newlines
                self.line_start_pos = (
                    self.char_pos + token.rindex(self.newline_char) + 1
                )

        self.char_pos += len(token)
        self.column = self.char_pos - self.line_start_pos + 1


class UnlessCallback:
    def __init__(self, scanner):
        self.scanner = scanner

    def __call__(self, t):
        res = self.scanner.match(t.value, 0)
        if res:
            _value, t.type = res
        return t


class CallChain:
    def __init__(self, callback1, callback2, cond):
        self.callback1 = callback1
        self.callback2 = callback2
        self.cond = cond

    def __call__(self, t):
        t2 = self.callback1(t)
        return self.callback2(t) if self.cond(t2) else t2


def _get_match(re_, regexp, s, flags):
    m = re_.match(regexp, s, flags)
    if m:
        return m.group(0)


def _create_unless(terminals, g_regex_flags, re_, use_bytes):
    tokens_by_type = classify(terminals, lambda t: type(t.pattern))
    assert len(tokens_by_type) <= 2, tokens_by_type.keys()
    embedded_strs = set()
    callback = {}
    for retok in tokens_by_type.get(PatternRE, []):
        unless = []
        for strtok in tokens_by_type.get(PatternStr, []):
            if strtok.priority != retok.priority:
                continue
            s = strtok.pattern.value
            if s == _get_match(re_, retok.pattern.to_regexp(), s, g_regex_flags):
                unless.append(strtok)
                if strtok.pattern.flags <= retok.pattern.flags:
                    embedded_strs.add(strtok)
        if unless:
            callback[retok.name] = UnlessCallback(
                Scanner(
                    unless, g_regex_flags, re_, match_whole=True, use_bytes=use_bytes
                )
            )

    new_terminals = [t for t in terminals if t not in embedded_strs]
    return new_terminals, callback


class Scanner:
    def __init__(self, terminals, g_regex_flags, re_, use_bytes, match_whole=False):
        self.terminals = terminals
        self.g_regex_flags = g_regex_flags
        self.re_ = re_
        self.use_bytes = use_bytes
        self.match_whole = match_whole

        self.allowed_types = {t.name for t in self.terminals}

        self._mres = self._build_mres(terminals, len(terminals))

    def _build_mres(self, terminals, max_size):
        ##

        ##

        ##

        postfix = "$" if self.match_whole else ""
        mres = []
        while terminals:
            pattern = "|".join(
                "(?P<%s>%s)" % (t.name, t.pattern.to_regexp() + postfix)
                for t in terminals[:max_size]
            )
            if self.use_bytes:
                pattern = pattern.encode("latin-1")
            try:
                mre = self.re_.compile(pattern, self.g_regex_flags)
            except AssertionError:  ##

                return self._build_mres(terminals, max_size // 2)

            mres.append(mre)
            terminals = terminals[max_size:]
        return mres

    def match(self, text, pos):
        for mre in self._mres:
            m = mre.match(text, pos)
            if m:
                return m.group(0), m.lastgroup


def _regexp_has_newline(r: str):
    #--
    return (
        "\n" in r or "\\n" in r or "\\s" in r or "[^" in r or ("(?s" in r and "." in r)
    )


class LexerState:
    #--

    __slots__ = "text", "line_ctr", "last_token"

    text: str
    line_ctr: LineCounter
    last_token: Optional[Token]

    def __init__(
        self,
        text: str,
        line_ctr: Optional[LineCounter] = None,
        last_token: Optional[Token] = None,
    ):
        self.text = text
        self.line_ctr = line_ctr or LineCounter(
            b"\n" if isinstance(text, bytes) else "\n"
        )
        self.last_token = last_token

    def __eq__(self, other):
        if not isinstance(other, LexerState):
            return NotImplemented

        return (
            self.text is other.text
            and self.line_ctr == other.line_ctr
            and self.last_token == other.last_token
        )

    def __copy__(self):
        return type(self)(self.text, copy(self.line_ctr), self.last_token)


class LexerThread:
    #--

    def __init__(self, lexer: "Lexer", lexer_state: LexerState):
        self.lexer = lexer
        self.state = lexer_state

    @classmethod
    def from_text(cls, lexer: "Lexer", text: str) -> "LexerThread":
        return cls(lexer, LexerState(text))

    def lex(self, parser_state):
        return self.lexer.lex(self.state, parser_state)

    def __copy__(self):
        return type(self)(self.lexer, copy(self.state))

    _Token = Token


_Callback = Callable[[Token], Token]


class Lexer(ABC):
    #--

    @abstractmethod
    def lex(self, lexer_state: LexerState, parser_state: Any) -> Iterator[Token]:
        return NotImplemented

    def make_lexer_state(self, text):
        #--
        return LexerState(text)


def _check_regex_collisions(
    terminal_to_regexp: Dict[TerminalDef, str],
    comparator,
    strict_mode,
    max_collisions_to_show=8,
):
    if not comparator:
        comparator = interegular.Comparator.from_regexes(terminal_to_regexp)

    ##

    ##

    max_time = 2 if strict_mode else 0.2

    ##

    if comparator.count_marked_pairs() >= max_collisions_to_show:
        return
    for group in classify(terminal_to_regexp, lambda t: t.priority).values():
        for a, b in comparator.check(group, skip_marked=True):
            assert a.priority == b.priority
            ##

            comparator.mark(a, b)

            ##

            message = f"Collision between Terminals {a.name} and {b.name}. "
            try:
                example = comparator.get_example_overlap(
                    a, b, max_time
                ).format_multiline()
            except ValueError:
                ##

                example = "No example could be found fast enough. However, the collision does still exists"
            if strict_mode:
                raise LexError(f"{message}\n{example}")
            logger.warning(
                "%s The lexer will choose between them arbitrarily.\n%s",
                message,
                example,
            )
            if comparator.count_marked_pairs() >= max_collisions_to_show:
                logger.warning("Found 8 regex collisions, will not check for more.")
                return


class AbstractBasicLexer(Lexer):
    terminals_by_name: Dict[str, TerminalDef]

    @abstractmethod
    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        ...

    @abstractmethod
    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        ...

    def lex(self, state: LexerState, parser_state: Any) -> Iterator[Token]:
        with suppress(EOFError):
            while True:
                yield self.next_token(state, parser_state)


class BasicLexer(AbstractBasicLexer):
    terminals: Collection[TerminalDef]
    ignore_types: FrozenSet[str]
    newline_types: FrozenSet[str]
    user_callbacks: Dict[str, _Callback]
    callback: Dict[str, _Callback]
    re: ModuleType

    def __init__(self, conf: "LexerConf", comparator=None) -> None:
        terminals = list(conf.terminals)
        assert all(isinstance(t, TerminalDef) for t in terminals), terminals

        self.re = conf.re_module

        if not conf.skip_validation:
            ##

            terminal_to_regexp = {}
            for t in terminals:
                regexp = t.pattern.to_regexp()
                try:
                    self.re.compile(regexp, conf.g_regex_flags)
                except self.re.error:
                    raise LexError("Cannot compile token %s: %s" % (t.name, t.pattern))

                if t.pattern.min_width == 0:
                    raise LexError(
                        "Lexer does not allow zero-width terminals. (%s: %s)"
                        % (t.name, t.pattern)
                    )
                if t.pattern.type == "re":
                    terminal_to_regexp[t] = regexp

            if not (set(conf.ignore) <= {t.name for t in terminals}):
                raise LexError(
                    "Ignore terminals are not defined: %s"
                    % (set(conf.ignore) - {t.name for t in terminals})
                )

            if has_interegular:
                _check_regex_collisions(terminal_to_regexp, comparator, conf.strict)
            elif conf.strict:
                raise LexError(
                    "interegular must be installed for strict mode. Use `pip install 'lark[interegular]'`."
                )

        ##

        self.newline_types = frozenset(
            t.name for t in terminals if _regexp_has_newline(t.pattern.to_regexp())
        )
        self.ignore_types = frozenset(conf.ignore)

        terminals.sort(
            key=lambda x: (
                -x.priority,
                -x.pattern.max_width,
                -len(x.pattern.value),
                x.name,
            )
        )
        self.terminals = terminals
        self.user_callbacks = conf.callbacks
        self.g_regex_flags = conf.g_regex_flags
        self.use_bytes = conf.use_bytes
        self.terminals_by_name = conf.terminals_by_name

        self._scanner = None

    def _build_scanner(self):
        terminals, self.callback = _create_unless(
            self.terminals, self.g_regex_flags, self.re, self.use_bytes
        )
        assert all(self.callback.values())

        for type_, f in self.user_callbacks.items():
            if type_ in self.callback:
                ##

                self.callback[type_] = CallChain(
                    self.callback[type_], f, lambda t: t.type == type_
                )
            else:
                self.callback[type_] = f

        self._scanner = Scanner(terminals, self.g_regex_flags, self.re, self.use_bytes)

    @property
    def scanner(self):
        if self._scanner is None:
            self._build_scanner()
        return self._scanner

    def match(self, text, pos):
        return self.scanner.match(text, pos)

    def next_token(self, lex_state: LexerState, parser_state: Any = None) -> Token:
        line_ctr = lex_state.line_ctr
        while line_ctr.char_pos < len(lex_state.text):
            res = self.match(lex_state.text, line_ctr.char_pos)
            if not res:
                allowed = self.scanner.allowed_types - self.ignore_types
                if not allowed:
                    allowed = {"<END-OF-FILE>"}
                raise UnexpectedCharacters(
                    lex_state.text,
                    line_ctr.char_pos,
                    line_ctr.line,
                    line_ctr.column,
                    allowed=allowed,
                    token_history=lex_state.last_token and [lex_state.last_token],
                    state=parser_state,
                    terminals_by_name=self.terminals_by_name,
                )

            value, type_ = res

            ignored = type_ in self.ignore_types
            t = None
            if not ignored or type_ in self.callback:
                t = Token(
                    type_, value, line_ctr.char_pos, line_ctr.line, line_ctr.column
                )
            line_ctr.feed(value, type_ in self.newline_types)
            if t is not None:
                t.end_line = line_ctr.line
                t.end_column = line_ctr.column
                t.end_pos = line_ctr.char_pos
                if t.type in self.callback:
                    t = self.callback[t.type](t)
                if not ignored:
                    if not isinstance(t, Token):
                        raise LexError(
                            "Callbacks must return a token (returned %r)" % t
                        )
                    lex_state.last_token = t
                    return t

        ##

        raise EOFError(self)


class ContextualLexer(Lexer):
    lexers: Dict[int, AbstractBasicLexer]
    root_lexer: AbstractBasicLexer

    BasicLexer: Type[AbstractBasicLexer] = BasicLexer

    def __init__(
        self,
        conf: "LexerConf",
        states: Dict[int, Collection[str]],
        always_accept: Collection[str] = (),
    ) -> None:
        terminals = list(conf.terminals)
        terminals_by_name = conf.terminals_by_name

        trad_conf = copy(conf)
        trad_conf.terminals = terminals

        if has_interegular and not conf.skip_validation:
            comparator = interegular.Comparator.from_regexes(
                {t: t.pattern.to_regexp() for t in terminals}
            )
        else:
            comparator = None
        lexer_by_tokens: Dict[FrozenSet[str], AbstractBasicLexer] = {}
        self.lexers = {}
        for state, accepts in states.items():
            key = frozenset(accepts)
            try:
                lexer = lexer_by_tokens[key]
            except KeyError:
                accepts = set(accepts) | set(conf.ignore) | set(always_accept)
                lexer_conf = copy(trad_conf)
                lexer_conf.terminals = [
                    terminals_by_name[n] for n in accepts if n in terminals_by_name
                ]
                lexer = self.BasicLexer(lexer_conf, comparator)
                lexer_by_tokens[key] = lexer

            self.lexers[state] = lexer

        assert trad_conf.terminals is terminals
        trad_conf.skip_validation = True  ##

        self.root_lexer = self.BasicLexer(trad_conf, comparator)

    def lex(
        self, lexer_state: LexerState, parser_state: "ParserState"
    ) -> Iterator[Token]:
        try:
            while True:
                lexer = self.lexers[parser_state.position]
                yield lexer.next_token(lexer_state, parser_state)
        except EOFError:
            pass
        except UnexpectedCharacters as e:
            ##

            ##

            try:
                last_token = (
                    lexer_state.last_token
                )  ##

                token = self.root_lexer.next_token(lexer_state, parser_state)
                raise UnexpectedToken(
                    token,
                    e.allowed,
                    state=parser_state,
                    token_history=[last_token],
                    terminals_by_name=self.root_lexer.terminals_by_name,
                )
            except UnexpectedCharacters:
                raise e  ##





_ParserArgType: "TypeAlias" = 'Literal["earley", "lalr", "cyk", "auto"]'
_LexerArgType: "TypeAlias" = 'Union[Literal["auto", "basic", "contextual", "dynamic", "dynamic_complete"], Type[Lexer]]'
_LexerCallback = Callable[[Token], Token]
ParserCallbacks = Dict[str, Callable]


class LexerConf(Serialize):
    __serialize_fields__ = (
        "terminals",
        "ignore",
        "g_regex_flags",
        "use_bytes",
        "lexer_type",
    )
    __serialize_namespace__ = (TerminalDef,)

    terminals: Collection[TerminalDef]
    re_module: ModuleType
    ignore: Collection[str]
    postlex: "Optional[PostLex]"
    callbacks: Dict[str, _LexerCallback]
    g_regex_flags: int
    skip_validation: bool
    use_bytes: bool
    lexer_type: Optional[_LexerArgType]
    strict: bool

    def __init__(
        self,
        terminals: Collection[TerminalDef],
        re_module: ModuleType,
        ignore: Collection[str] = (),
        postlex: "Optional[PostLex]" = None,
        callbacks: Optional[Dict[str, _LexerCallback]] = None,
        g_regex_flags: int = 0,
        skip_validation: bool = False,
        use_bytes: bool = False,
        strict: bool = False,
    ):
        self.terminals = terminals
        self.terminals_by_name = {t.name: t for t in self.terminals}
        assert len(self.terminals) == len(self.terminals_by_name)
        self.ignore = ignore
        self.postlex = postlex
        self.callbacks = callbacks or {}
        self.g_regex_flags = g_regex_flags
        self.re_module = re_module
        self.skip_validation = skip_validation
        self.use_bytes = use_bytes
        self.strict = strict
        self.lexer_type = None

    def _deserialize(self):
        self.terminals_by_name = {t.name: t for t in self.terminals}

    def __deepcopy__(self, memo=None):
        return type(self)(
            deepcopy(self.terminals, memo),
            self.re_module,
            deepcopy(self.ignore, memo),
            deepcopy(self.postlex, memo),
            deepcopy(self.callbacks, memo),
            deepcopy(self.g_regex_flags, memo),
            deepcopy(self.skip_validation, memo),
            deepcopy(self.use_bytes, memo),
        )


class ParserConf(Serialize):
    __serialize_fields__ = "rules", "start", "parser_type"

    rules: List["Rule"]
    callbacks: ParserCallbacks
    start: List[str]
    parser_type: _ParserArgType

    def __init__(
        self, rules: List["Rule"], callbacks: ParserCallbacks, start: List[str]
    ):
        assert isinstance(start, list)
        self.rules = rules
        self.callbacks = callbacks
        self.start = start



from functools import partial, wraps
from itertools import product


class ExpandSingleChild:
    def __init__(self, node_builder):
        self.node_builder = node_builder

    def __call__(self, children):
        if len(children) == 1:
            return children[0]
        else:
            return self.node_builder(children)


class PropagatePositions:
    def __init__(self, node_builder, node_filter=None):
        self.node_builder = node_builder
        self.node_filter = node_filter

    def __call__(self, children):
        res = self.node_builder(children)

        if isinstance(res, Tree):
            ##

            ##

            ##

            ##


            res_meta = res.meta

            first_meta = self._pp_get_meta(children)
            if first_meta is not None:
                if not hasattr(res_meta, "line"):
                    ##

                    res_meta.line = getattr(
                        first_meta, "container_line", first_meta.line
                    )
                    res_meta.column = getattr(
                        first_meta, "container_column", first_meta.column
                    )
                    res_meta.start_pos = getattr(
                        first_meta, "container_start_pos", first_meta.start_pos
                    )
                    res_meta.empty = False

                res_meta.container_line = getattr(
                    first_meta, "container_line", first_meta.line
                )
                res_meta.container_column = getattr(
                    first_meta, "container_column", first_meta.column
                )
                res_meta.container_start_pos = getattr(
                    first_meta, "container_start_pos", first_meta.start_pos
                )

            last_meta = self._pp_get_meta(reversed(children))
            if last_meta is not None:
                if not hasattr(res_meta, "end_line"):
                    res_meta.end_line = getattr(
                        last_meta, "container_end_line", last_meta.end_line
                    )
                    res_meta.end_column = getattr(
                        last_meta, "container_end_column", last_meta.end_column
                    )
                    res_meta.end_pos = getattr(
                        last_meta, "container_end_pos", last_meta.end_pos
                    )
                    res_meta.empty = False

                res_meta.container_end_line = getattr(
                    last_meta, "container_end_line", last_meta.end_line
                )
                res_meta.container_end_column = getattr(
                    last_meta, "container_end_column", last_meta.end_column
                )
                res_meta.container_end_pos = getattr(
                    last_meta, "container_end_pos", last_meta.end_pos
                )

        return res

    def _pp_get_meta(self, children):
        for c in children:
            if self.node_filter is not None and not self.node_filter(c):
                continue
            if isinstance(c, Tree):
                if not c.meta.empty:
                    return c.meta
            elif isinstance(c, Token):
                return c
            elif hasattr(c, "__lark_meta__"):
                return c.__lark_meta__()


def make_propagate_positions(option):
    if callable(option):
        return partial(PropagatePositions, node_filter=option)
    elif option is True:
        return PropagatePositions
    elif option is False:
        return None

    raise ConfigurationError("Invalid option for propagate_positions: %r" % option)


class ChildFilter:
    def __init__(self, to_include, append_none, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include
        self.append_none = append_none

    def __call__(self, children):
        filtered = []

        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                filtered += children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR(ChildFilter):
    #--

    def __call__(self, children):
        filtered = []
        for i, to_expand, add_none in self.to_include:
            if add_none:
                filtered += [None] * add_none
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])

        if self.append_none:
            filtered += [None] * self.append_none

        return self.node_builder(filtered)


class ChildFilterLALR_NoPlaceholders(ChildFilter):
    #--

    def __init__(self, to_include, node_builder):
        self.node_builder = node_builder
        self.to_include = to_include

    def __call__(self, children):
        filtered = []
        for i, to_expand in self.to_include:
            if to_expand:
                if filtered:
                    filtered += children[i].children
                else:  ##

                    filtered = children[i].children
            else:
                filtered.append(children[i])
        return self.node_builder(filtered)


def _should_expand(sym):
    return not sym.is_term and sym.name.startswith("_")


def maybe_create_child_filter(
    expansion, keep_all_tokens, ambiguous, _empty_indices: List[bool]
):
    ##

    if _empty_indices:
        assert _empty_indices.count(False) == len(expansion)
        s = "".join(str(int(b)) for b in _empty_indices)
        empty_indices = [len(ones) for ones in s.split("0")]
        assert len(empty_indices) == len(expansion) + 1, (empty_indices, len(expansion))
    else:
        empty_indices = [0] * (len(expansion) + 1)

    to_include = []
    nones_to_add = 0
    for i, sym in enumerate(expansion):
        nones_to_add += empty_indices[i]
        if keep_all_tokens or not (sym.is_term and sym.filter_out):
            to_include.append((i, _should_expand(sym), nones_to_add))
            nones_to_add = 0

    nones_to_add += empty_indices[len(expansion)]

    if (
        _empty_indices
        or len(to_include) < len(expansion)
        or any(to_expand for i, to_expand, _ in to_include)
    ):
        if _empty_indices or ambiguous:
            return partial(
                ChildFilter if ambiguous else ChildFilterLALR, to_include, nones_to_add
            )
        else:
            ##

            return partial(
                ChildFilterLALR_NoPlaceholders, [(i, x) for i, x, _ in to_include]
            )


class AmbiguousExpander:
    #--

    def __init__(self, to_expand, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class
        self.to_expand = to_expand

    def __call__(self, children):
        def _is_ambig_tree(t):
            return hasattr(t, "data") and t.data == "_ambig"

        ##

        ##

        ##

        ##

        ambiguous = []
        for i, child in enumerate(children):
            if _is_ambig_tree(child):
                if i in self.to_expand:
                    ambiguous.append(i)

                child.expand_kids_by_data("_ambig")

        if not ambiguous:
            return self.node_builder(children)

        expand = [
            child.children if i in ambiguous else (child,)
            for i, child in enumerate(children)
        ]
        return self.tree_class(
            "_ambig", [self.node_builder(list(f)) for f in product(*expand)]
        )


def maybe_create_ambiguous_expander(tree_class, expansion, keep_all_tokens):
    to_expand = [
        i
        for i, sym in enumerate(expansion)
        if keep_all_tokens
        or ((not (sym.is_term and sym.filter_out)) and _should_expand(sym))
    ]
    if to_expand:
        return partial(AmbiguousExpander, to_expand, tree_class)


class AmbiguousIntermediateExpander:
    #--

    def __init__(self, tree_class, node_builder):
        self.node_builder = node_builder
        self.tree_class = tree_class

    def __call__(self, children):
        def _is_iambig_tree(child):
            return hasattr(child, "data") and child.data == "_iambig"

        def _collapse_iambig(children):
            #--

            ##

            ##

            if children and _is_iambig_tree(children[0]):
                iambig_node = children[0]
                result = []
                for grandchild in iambig_node.children:
                    collapsed = _collapse_iambig(grandchild.children)
                    if collapsed:
                        for child in collapsed:
                            child.children += children[1:]
                        result += collapsed
                    else:
                        new_tree = self.tree_class(
                            "_inter", grandchild.children + children[1:]
                        )
                        result.append(new_tree)
                return result

        collapsed = _collapse_iambig(children)
        if collapsed:
            processed_nodes = [self.node_builder(c.children) for c in collapsed]
            return self.tree_class("_ambig", processed_nodes)

        return self.node_builder(children)


def inplace_transformer(func):
    @wraps(func)
    def f(children):
        ##

        tree = Tree(func.__name__, children)
        return func(tree)

    return f


def apply_visit_wrapper(func, name, wrapper):
    if wrapper is _vargs_meta or wrapper is _vargs_meta_inline:
        raise NotImplementedError("Meta args not supported for internal transformer")

    @wraps(func)
    def f(children):
        return wrapper(func, name, children, None)

    return f


class ParseTreeBuilder:
    def __init__(
        self,
        rules,
        tree_class,
        propagate_positions=False,
        ambiguous=False,
        maybe_placeholders=False,
    ):
        self.tree_class = tree_class
        self.propagate_positions = propagate_positions
        self.ambiguous = ambiguous
        self.maybe_placeholders = maybe_placeholders

        self.rule_builders = list(self._init_builders(rules))

    def _init_builders(self, rules):
        propagate_positions = make_propagate_positions(self.propagate_positions)

        for rule in rules:
            options = rule.options
            keep_all_tokens = options.keep_all_tokens
            expand_single_child = options.expand1

            wrapper_chain = list(
                filter(
                    None,
                    [
                        (expand_single_child and not rule.alias) and ExpandSingleChild,
                        maybe_create_child_filter(
                            rule.expansion,
                            keep_all_tokens,
                            self.ambiguous,
                            options.empty_indices if self.maybe_placeholders else None,
                        ),
                        propagate_positions,
                        self.ambiguous
                        and maybe_create_ambiguous_expander(
                            self.tree_class, rule.expansion, keep_all_tokens
                        ),
                        self.ambiguous
                        and partial(AmbiguousIntermediateExpander, self.tree_class),
                    ],
                )
            )

            yield rule, wrapper_chain

    def create_callback(self, transformer=None):
        callbacks = {}

        default_handler = getattr(transformer, "__default__", None)
        if default_handler:

            def default_callback(data, children):
                return default_handler(data, children, None)

        else:
            default_callback = self.tree_class

        for rule, wrapper_chain in self.rule_builders:
            user_callback_name = (
                rule.alias or rule.options.template_source or rule.origin.name
            )
            try:
                f = getattr(transformer, user_callback_name)
                wrapper = getattr(f, "visit_wrapper", None)
                if wrapper is not None:
                    f = apply_visit_wrapper(f, user_callback_name, wrapper)
                elif isinstance(transformer, Transformer_InPlace):
                    f = inplace_transformer(f)
            except AttributeError:
                f = partial(default_callback, user_callback_name)

            for w in wrapper_chain:
                f = w(f)

            if rule in callbacks:
                raise GrammarError("Rule '%s' already exists" % (rule,))

            callbacks[rule] = f

        return callbacks





class Action:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return str(self)


Shift = Action("Shift")
Reduce = Action("Reduce")

StateT = TypeVar("StateT")


class ParseTableBase(Generic[StateT]):
    states: Dict[StateT, Dict[str, Tuple]]
    start_states: Dict[str, StateT]
    end_states: Dict[str, StateT]

    def __init__(self, states, start_states, end_states):
        self.states = states
        self.start_states = start_states
        self.end_states = end_states

    def serialize(self, memo):
        tokens = Enumerator()

        states = {
            state: {
                tokens.get(token): (
                    (1, arg.serialize(memo)) if action is Reduce else (0, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in self.states.items()
        }

        return {
            "tokens": tokens.reversed(),
            "states": states,
            "start_states": self.start_states,
            "end_states": self.end_states,
        }

    @classmethod
    def deserialize(cls, data, memo):
        tokens = data["tokens"]
        states = {
            state: {
                tokens[token]: (
                    (Reduce, Rule.deserialize(arg, memo))
                    if action == 1
                    else (Shift, arg)
                )
                for token, (action, arg) in actions.items()
            }
            for state, actions in data["states"].items()
        }
        return cls(states, data["start_states"], data["end_states"])


class ParseTable(ParseTableBase["State"]):
    #--

    pass


class IntParseTable(ParseTableBase[int]):
    #--

    @classmethod
    def from_ParseTable(cls, parse_table: ParseTable):
        enum = list(parse_table.states)
        state_to_idx: Dict["State", int] = {s: i for i, s in enumerate(enum)}
        int_states = {}

        for s, la in parse_table.states.items():
            la = {
                k: (v[0], state_to_idx[v[1]]) if v[0] is Shift else v
                for k, v in la.items()
            }
            int_states[state_to_idx[s]] = la

        start_states = {
            start: state_to_idx[s] for start, s in parse_table.start_states.items()
        }
        end_states = {
            start: state_to_idx[s] for start, s in parse_table.end_states.items()
        }
        return cls(int_states, start_states, end_states)





class ParseConf(Generic[StateT]):
    __slots__ = (
        "parse_table",
        "callbacks",
        "start",
        "start_state",
        "end_state",
        "states",
    )

    parse_table: ParseTableBase[StateT]
    callbacks: ParserCallbacks
    start: str

    start_state: StateT
    end_state: StateT
    states: Dict[StateT, Dict[str, tuple]]

    def __init__(
        self,
        parse_table: ParseTableBase[StateT],
        callbacks: ParserCallbacks,
        start: str,
    ):
        self.parse_table = parse_table

        self.start_state = self.parse_table.start_states[start]
        self.end_state = self.parse_table.end_states[start]
        self.states = self.parse_table.states

        self.callbacks = callbacks
        self.start = start


class ParserState(Generic[StateT]):
    __slots__ = "parse_conf", "lexer", "state_stack", "value_stack"

    parse_conf: ParseConf[StateT]
    lexer: LexerThread
    state_stack: List[StateT]
    value_stack: list

    def __init__(
        self,
        parse_conf: ParseConf[StateT],
        lexer: LexerThread,
        state_stack=None,
        value_stack=None,
    ):
        self.parse_conf = parse_conf
        self.lexer = lexer
        self.state_stack = state_stack or [self.parse_conf.start_state]
        self.value_stack = value_stack or []

    @property
    def position(self) -> StateT:
        return self.state_stack[-1]

    ##

    def __eq__(self, other) -> bool:
        if not isinstance(other, ParserState):
            return NotImplemented
        return (
            len(self.state_stack) == len(other.state_stack)
            and self.position == other.position
        )

    def __copy__(self):
        return type(self)(
            self.parse_conf,
            self.lexer,  ##

            copy(self.state_stack),
            deepcopy(self.value_stack),
        )

    def copy(self) -> "ParserState[StateT]":
        return copy(self)

    def feed_token(self, token: Token, is_end=False) -> Any:
        state_stack = self.state_stack
        value_stack = self.value_stack
        states = self.parse_conf.states
        end_state = self.parse_conf.end_state
        callbacks = self.parse_conf.callbacks

        while True:
            state = state_stack[-1]
            try:
                action, arg = states[state][token.type]
            except KeyError:
                expected = {s for s in states[state].keys() if s.isupper()}
                raise UnexpectedToken(
                    token, expected, state=self, interactive_parser=None
                )

            assert arg != end_state

            if action is Shift:
                ##

                assert not is_end
                state_stack.append(arg)
                value_stack.append(
                    token
                    if token.type not in callbacks
                    else callbacks[token.type](token)
                )
                return
            else:
                ##

                rule = arg
                size = len(rule.expansion)
                if size:
                    s = value_stack[-size:]
                    del state_stack[-size:]
                    del value_stack[-size:]
                else:
                    s = []

                value = callbacks[rule](s) if callbacks else s

                _action, new_state = states[state_stack[-1]][rule.origin.name]
                assert _action is Shift
                state_stack.append(new_state)
                value_stack.append(value)

                if is_end and state_stack[-1] == end_state:
                    return value_stack[-1]





class LALR_Parser(Serialize):
    def __init__(
        self, parser_conf: ParserConf, debug: bool = False, strict: bool = False
    ):
        analysis = LALR_Analyzer(parser_conf, debug=debug, strict=strict)
        analysis.compute_lalr()
        callbacks = parser_conf.callbacks

        self._parse_table = analysis.parse_table
        self.parser_conf = parser_conf
        self.parser = _Parser(analysis.parse_table, callbacks, debug)

    @classmethod
    def deserialize(cls, data, memo, callbacks, debug=False):
        inst = cls.__new__(cls)
        inst._parse_table = IntParseTable.deserialize(data, memo)
        inst.parser = _Parser(inst._parse_table, callbacks, debug)
        return inst

    def serialize(self, memo: Any = None) -> Dict[str, Any]:
        return self._parse_table.serialize(memo)

    def parse_interactive(self, lexer: LexerThread, start: str):
        return self.parser.parse(lexer, start, start_interactive=True)

    def parse(self, lexer, start, on_error=None):
        try:
            return self.parser.parse(lexer, start)
        except UnexpectedInput as e:
            if on_error is None:
                raise

            while True:
                if isinstance(e, UnexpectedCharacters):
                    s = e.interactive_parser.lexer_thread.state
                    p = s.line_ctr.char_pos

                if not on_error(e):
                    raise e

                if isinstance(e, UnexpectedCharacters):
                    ##

                    if p == s.line_ctr.char_pos:
                        s.line_ctr.feed(s.text[p : p + 1])

                try:
                    return e.interactive_parser.resume_parse()
                except UnexpectedToken as e2:
                    if (
                        isinstance(e, UnexpectedToken)
                        and e.token.type == e2.token.type == "$END"
                        and e.interactive_parser == e2.interactive_parser
                    ):
                        ##

                        raise e2
                    e = e2
                except UnexpectedCharacters as e2:
                    e = e2


class _Parser:
    parse_table: ParseTableBase
    callbacks: ParserCallbacks
    debug: bool

    def __init__(
        self,
        parse_table: ParseTableBase,
        callbacks: ParserCallbacks,
        debug: bool = False,
    ):
        self.parse_table = parse_table
        self.callbacks = callbacks
        self.debug = debug

    def parse(
        self,
        lexer: LexerThread,
        start: str,
        value_stack=None,
        state_stack=None,
        start_interactive=False,
    ):
        parse_conf = ParseConf(self.parse_table, self.callbacks, start)
        parser_state = ParserState(parse_conf, lexer, state_stack, value_stack)
        if start_interactive:
            return InteractiveParser(self, parser_state, parser_state.lexer)
        return self.parse_from_state(parser_state)

    def parse_from_state(self, state: ParserState, last_token: Optional[Token] = None):
        #--
        try:
            token = last_token
            for token in state.lexer.lex(state):
                assert token is not None
                state.feed_token(token)

            end_token = (
                Token.new_borrow_pos("$END", "", token)
                if token
                else Token("$END", "", 0, 1, 1)
            )
            return state.feed_token(end_token, True)
        except UnexpectedInput as e:
            try:
                e.interactive_parser = InteractiveParser(self, state, state.lexer)
            except NameError:
                pass
            raise e
        except Exception as e:
            if self.debug:
                print("")
                print("STATE STACK DUMP")
                print("----------------")
                for i, s in enumerate(state.state_stack):
                    print("%d)" % i, s)
                print("")

            raise





class InteractiveParser:
    #--

    def __init__(self, parser, parser_state, lexer_thread: LexerThread):
        self.parser = parser
        self.parser_state = parser_state
        self.lexer_thread = lexer_thread
        self.result = None

    @property
    def lexer_state(self) -> LexerThread:
        warnings.warn(
            "lexer_state will be removed in subsequent releases. Use lexer_thread instead.",
            DeprecationWarning,
        )
        return self.lexer_thread

    def feed_token(self, token: Token):
        #--
        return self.parser_state.feed_token(token, token.type == "$END")

    def iter_parse(self) -> Iterator[Token]:
        #--
        for token in self.lexer_thread.lex(self.parser_state):
            yield token
            self.result = self.feed_token(token)

    def exhaust_lexer(self) -> List[Token]:
        #--
        return list(self.iter_parse())

    def feed_eof(self, last_token=None):
        #--
        eof = (
            Token.new_borrow_pos("$END", "", last_token)
            if last_token is not None
            else self.lexer_thread._Token("$END", "", 0, 1, 1)
        )
        return self.feed_token(eof)

    def __copy__(self):
        #--
        return type(self)(
            self.parser,
            copy(self.parser_state),
            copy(self.lexer_thread),
        )

    def copy(self):
        return copy(self)

    def __eq__(self, other):
        if not isinstance(other, InteractiveParser):
            return False

        return (
            self.parser_state == other.parser_state
            and self.lexer_thread == other.lexer_thread
        )

    def as_immutable(self):
        #--
        p = copy(self)
        return ImmutableInteractiveParser(p.parser, p.parser_state, p.lexer_thread)

    def pretty(self):
        #--
        out = ["Parser choices:"]
        for k, v in self.choices().items():
            out.append("\t- %s -> %r" % (k, v))
        out.append("stack size: %s" % len(self.parser_state.state_stack))
        return "\n".join(out)

    def choices(self):
        #--
        return self.parser_state.parse_conf.parse_table.states[
            self.parser_state.position
        ]

    def accepts(self):
        #--
        accepts = set()
        conf_no_callbacks = copy(self.parser_state.parse_conf)
        ##

        ##

        conf_no_callbacks.callbacks = {}
        for t in self.choices():
            if t.isupper():  ##

                new_cursor = copy(self)
                new_cursor.parser_state.parse_conf = conf_no_callbacks
                try:
                    new_cursor.feed_token(self.lexer_thread._Token(t, ""))
                except UnexpectedToken:
                    pass
                else:
                    accepts.add(t)
        return accepts

    def resume_parse(self):
        #--
        return self.parser.parse_from_state(
            self.parser_state, last_token=self.lexer_thread.state.last_token
        )


class ImmutableInteractiveParser(InteractiveParser):
    #--

    result = None

    def __hash__(self):
        return hash((self.parser_state, self.lexer_thread))

    def feed_token(self, token):
        c = copy(self)
        c.result = InteractiveParser.feed_token(c, token)
        return c

    def exhaust_lexer(self):
        #--
        cursor = self.as_mutable()
        cursor.exhaust_lexer()
        return cursor.as_immutable()

    def as_mutable(self):
        #--
        p = copy(self)
        return InteractiveParser(p.parser, p.parser_state, p.lexer_thread)





def _wrap_lexer(lexer_class):
    future_interface = getattr(lexer_class, "__future_interface__", False)
    if future_interface:
        return lexer_class
    else:

        class CustomLexerWrapper(Lexer):
            def __init__(self, lexer_conf):
                self.lexer = lexer_class(lexer_conf)

            def lex(self, lexer_state, parser_state):
                return self.lexer.lex(lexer_state.text)

        return CustomLexerWrapper


def _deserialize_parsing_frontend(data, memo, lexer_conf, callbacks, options):
    parser_conf = ParserConf.deserialize(data["parser_conf"], memo)
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    parser = cls.deserialize(data["parser"], memo, callbacks, options.debug)
    parser_conf.callbacks = callbacks
    return ParsingFrontend(lexer_conf, parser_conf, options, parser=parser)


_parser_creators: "Dict[str, Callable[[LexerConf, Any, Any], Any]]" = {}


class ParsingFrontend(Serialize):
    __serialize_fields__ = "lexer_conf", "parser_conf", "parser"

    lexer_conf: LexerConf
    parser_conf: ParserConf
    options: Any

    def __init__(
        self, lexer_conf: LexerConf, parser_conf: ParserConf, options, parser=None
    ):
        self.parser_conf = parser_conf
        self.lexer_conf = lexer_conf
        self.options = options

        ##

        if parser:  ##

            self.parser = parser
        else:
            create_parser = _parser_creators.get(parser_conf.parser_type)
            assert (
                create_parser is not None
            ), "{} is not supported in standalone mode".format(parser_conf.parser_type)
            self.parser = create_parser(lexer_conf, parser_conf, options)

        ##

        lexer_type = lexer_conf.lexer_type
        self.skip_lexer = False
        if lexer_type in ("dynamic", "dynamic_complete"):
            assert lexer_conf.postlex is None
            self.skip_lexer = True
            return

        if isinstance(lexer_type, type):
            assert issubclass(lexer_type, Lexer)
            self.lexer = _wrap_lexer(lexer_type)(lexer_conf)
        elif isinstance(lexer_type, str):
            create_lexer = {
                "basic": create_basic_lexer,
                "contextual": create_contextual_lexer,
            }[lexer_type]
            self.lexer = create_lexer(
                lexer_conf, self.parser, lexer_conf.postlex, options
            )
        else:
            raise TypeError("Bad value for lexer_type: {lexer_type}")

        if lexer_conf.postlex:
            self.lexer = PostLexConnector(self.lexer, lexer_conf.postlex)

    def _verify_start(self, start=None):
        if start is None:
            start_decls = self.parser_conf.start
            if len(start_decls) > 1:
                raise ConfigurationError(
                    "Lark initialized with more than 1 possible start rule. Must specify which start rule to parse",
                    start_decls,
                )
            (start,) = start_decls
        elif start not in self.parser_conf.start:
            raise ConfigurationError(
                "Unknown start rule %s. Must be one of %r"
                % (start, self.parser_conf.start)
            )
        return start

    def _make_lexer_thread(self, text: str) -> Union[str, LexerThread]:
        cls = (self.options and self.options._plugins.get("LexerThread")) or LexerThread
        return text if self.skip_lexer else cls.from_text(self.lexer, text)

    def parse(self, text: str, start=None, on_error=None):
        chosen_start = self._verify_start(start)
        kw = {} if on_error is None else {"on_error": on_error}
        stream = self._make_lexer_thread(text)
        return self.parser.parse(stream, chosen_start, **kw)

    def parse_interactive(self, text: Optional[str] = None, start=None):
        ##

        ##

        chosen_start = self._verify_start(start)
        if self.parser_conf.parser_type != "lalr":
            raise ConfigurationError(
                "parse_interactive() currently only works with parser='lalr' "
            )
        stream = self._make_lexer_thread(text)  ##

        return self.parser.parse_interactive(stream, chosen_start)


def _validate_frontend_args(parser, lexer) -> None:
    assert_config(parser, ("lalr", "earley", "cyk"))
    if not isinstance(lexer, type):  ##

        expected = {
            "lalr": ("basic", "contextual"),
            "earley": ("basic", "dynamic", "dynamic_complete"),
            "cyk": ("basic",),
        }[parser]
        assert_config(
            lexer,
            expected,
            "Parser %r does not support lexer %%r, expected one of %%s" % parser,
        )


def _get_lexer_callbacks(transformer, terminals):
    result = {}
    for terminal in terminals:
        callback = getattr(transformer, terminal.name, None)
        if callback is not None:
            result[terminal.name] = callback
    return result


class PostLexConnector:
    def __init__(self, lexer, postlexer):
        self.lexer = lexer
        self.postlexer = postlexer

    def lex(self, lexer_state, parser_state):
        i = self.lexer.lex(lexer_state, parser_state)
        return self.postlexer.process(i)


def create_basic_lexer(lexer_conf, parser, postlex, options) -> BasicLexer:
    cls = (options and options._plugins.get("BasicLexer")) or BasicLexer
    return cls(lexer_conf)


def create_contextual_lexer(
    lexer_conf: LexerConf, parser, postlex, options
) -> ContextualLexer:
    cls = (options and options._plugins.get("ContextualLexer")) or ContextualLexer
    parse_table: ParseTableBase[int] = parser._parse_table
    states: Dict[int, Collection[str]] = {
        idx: list(t.keys()) for idx, t in parse_table.states.items()
    }
    always_accept: Collection[str] = postlex.always_accept if postlex else ()
    return cls(lexer_conf, states, always_accept=always_accept)


def create_lalr_parser(
    lexer_conf: LexerConf, parser_conf: ParserConf, options=None
) -> LALR_Parser:
    debug = options.debug if options else False
    strict = options.strict if options else False
    cls = (options and options._plugins.get("LALR_Parser")) or LALR_Parser
    return cls(parser_conf, debug=debug, strict=strict)


_parser_creators["lalr"] = create_lalr_parser




class PostLex(ABC):
    @abstractmethod
    def process(self, stream: Iterator[Token]) -> Iterator[Token]:
        return stream

    always_accept: Iterable[str] = ()


class LarkOptions(Serialize):
    #--

    start: List[str]
    debug: bool
    strict: bool
    transformer: "Optional[Transformer]"
    propagate_positions: Union[bool, str]
    maybe_placeholders: bool
    cache: Union[bool, str]
    regex: bool
    g_regex_flags: int
    keep_all_tokens: bool
    tree_class: Optional[Callable[[str, List], Any]]
    parser: _ParserArgType
    lexer: _LexerArgType
    ambiguity: 'Literal["auto", "resolve", "explicit", "forest"]'
    postlex: Optional[PostLex]
    priority: 'Optional[Literal["auto", "normal", "invert"]]'
    lexer_callbacks: Dict[str, Callable[[Token], Token]]
    use_bytes: bool
    ordered_sets: bool
    edit_terminals: Optional[Callable[[TerminalDef], TerminalDef]]
    import_paths: "List[Union[str, Callable[[Union[None, str, PackageResource], str], Tuple[str, str]]]]"
    source_path: Optional[str]

    OPTIONS_DOC = r"""
    **===  General Options  ===**

    start
            The start symbol. Either a string, or a list of strings for multiple possible starts (Default: "start")
    debug
            Display debug information and extra warnings. Use only when debugging (Default: ``False``)
            When used with Earley, it generates a forest graph as "sppf.png", if 'dot' is installed.
    strict
            Throw an exception on any potential ambiguity, including shift/reduce conflicts, and regex collisions.
    transformer
            Applies the transformer to every parse tree (equivalent to applying it after the parse, but faster)
    propagate_positions
            Propagates positional attributes into the 'meta' attribute of all tree branches.
            Sets attributes: (line, column, end_line, end_column, start_pos, end_pos,
                              container_line, container_column, container_end_line, container_end_column)
            Accepts ``False``, ``True``, or a callable, which will filter which nodes to ignore when propagating.
    maybe_placeholders
            When ``True``, the ``[]`` operator returns ``None`` when not matched.
            When ``False``,  ``[]`` behaves like the ``?`` operator, and returns no value at all.
            (default= ``True``)
    cache
            Cache the results of the Lark grammar analysis, for x2 to x3 faster loading. LALR only for now.

            - When ``False``, does nothing (default)
            - When ``True``, caches to a temporary file in the local directory
            - When given a string, caches to the path pointed by the string
    regex
            When True, uses the ``regex`` module instead of the stdlib ``re``.
    g_regex_flags
            Flags that are applied to all terminals (both regex and strings)
    keep_all_tokens
            Prevent the tree builder from automagically removing "punctuation" tokens (Default: ``False``)
    tree_class
            Lark will produce trees comprised of instances of this class instead of the default ``lark.Tree``.

    **=== Algorithm Options ===**

    parser
            Decides which parser engine to use. Accepts "earley" or "lalr". (Default: "earley").
            (there is also a "cyk" option for legacy)
    lexer
            Decides whether or not to use a lexer stage

            - "auto" (default): Choose for me based on the parser
            - "basic": Use a basic lexer
            - "contextual": Stronger lexer (only works with parser="lalr")
            - "dynamic": Flexible and powerful (only with parser="earley")
            - "dynamic_complete": Same as dynamic, but tries *every* variation of tokenizing possible.
    ambiguity
            Decides how to handle ambiguity in the parse. Only relevant if parser="earley"

            - "resolve": The parser will automatically choose the simplest derivation
              (it chooses consistently: greedy for tokens, non-greedy for rules)
            - "explicit": The parser will return all derivations wrapped in "_ambig" tree nodes (i.e. a forest).
            - "forest": The parser will return the root of the shared packed parse forest.

    **=== Misc. / Domain Specific Options ===**

    postlex
            Lexer post-processing (Default: ``None``) Only works with the basic and contextual lexers.
    priority
            How priorities should be evaluated - "auto", ``None``, "normal", "invert" (Default: "auto")
    lexer_callbacks
            Dictionary of callbacks for the lexer. May alter tokens during lexing. Use with caution.
    use_bytes
            Accept an input of type ``bytes`` instead of ``str``.
    ordered_sets
            Should Earley use ordered-sets to achieve stable output (~10% slower than regular sets. Default: True)
    edit_terminals
            A callback for editing the terminals before parse.
    import_paths
            A List of either paths or loader functions to specify from where grammars are imported
    source_path
            Override the source of from where the grammar was loaded. Useful for relative imports and unconventional grammar loading
    **=== End of Options ===**
    """
    if __doc__:
        __doc__ += OPTIONS_DOC

    ##

    ##

    ##

    ##

    ##

    ##

    _defaults: Dict[str, Any] = {
        "debug": False,
        "strict": False,
        "keep_all_tokens": False,
        "tree_class": None,
        "cache": False,
        "postlex": None,
        "parser": "earley",
        "lexer": "auto",
        "transformer": None,
        "start": "start",
        "priority": "auto",
        "ambiguity": "auto",
        "regex": False,
        "propagate_positions": False,
        "lexer_callbacks": {},
        "maybe_placeholders": True,
        "edit_terminals": None,
        "g_regex_flags": 0,
        "use_bytes": False,
        "ordered_sets": True,
        "import_paths": [],
        "source_path": None,
        "_plugins": {},
    }

    def __init__(self, options_dict: Dict[str, Any]) -> None:
        o = dict(options_dict)

        options = {}
        for name, default in self._defaults.items():
            if name in o:
                value = o.pop(name)
                if isinstance(default, bool) and name not in (
                    "cache",
                    "use_bytes",
                    "propagate_positions",
                ):
                    value = bool(value)
            else:
                value = default

            options[name] = value

        if isinstance(options["start"], str):
            options["start"] = [options["start"]]

        self.__dict__["options"] = options

        assert_config(self.parser, ("earley", "lalr", "cyk", None))

        if self.parser == "earley" and self.transformer:
            raise ConfigurationError(
                "Cannot specify an embedded transformer when using the Earley algorithm. "
                "Please use your transformer on the resulting parse tree, or use a different algorithm (i.e. LALR)"
            )

        if o:
            raise ConfigurationError("Unknown options: %s" % o.keys())

    def __getattr__(self, name: str) -> Any:
        try:
            return self.__dict__["options"][name]
        except KeyError as e:
            raise AttributeError(e)

    def __setattr__(self, name: str, value: str) -> None:
        assert_config(
            name, self.options.keys(), "%r isn't a valid option. Expected one of: %s"
        )
        self.options[name] = value

    def serialize(self, memo=None) -> Dict[str, Any]:
        return self.options

    @classmethod
    def deserialize(
        cls, data: Dict[str, Any], memo: Dict[int, Union[TerminalDef, Rule]]
    ) -> "LarkOptions":
        return cls(data)


##

##

_LOAD_ALLOWED_OPTIONS = {
    "postlex",
    "transformer",
    "lexer_callbacks",
    "use_bytes",
    "debug",
    "g_regex_flags",
    "regex",
    "propagate_positions",
    "tree_class",
    "_plugins",
}

_VALID_PRIORITY_OPTIONS = ("auto", "normal", "invert", None)
_VALID_AMBIGUITY_OPTIONS = ("auto", "resolve", "explicit", "forest")


_T = TypeVar("_T", bound="Lark")


class Lark(Serialize):
    #--

    source_path: str
    source_grammar: str
    grammar: "Grammar"
    options: LarkOptions
    lexer: Lexer
    parser: "ParsingFrontend"
    terminals: Collection[TerminalDef]

    def __init__(self, grammar: "Union[Grammar, str, IO[str]]", **options) -> None:
        self.options = LarkOptions(options)
        re_module: types.ModuleType

        ##

        use_regex = self.options.regex
        if use_regex:
            if _has_regex:
                re_module = regex
            else:
                raise ImportError(
                    "`regex` module must be installed if calling `Lark(regex=True)`."
                )
        else:
            re_module = re

        ##

        if self.options.source_path is None:
            try:
                self.source_path = grammar.name  ##

            except AttributeError:
                self.source_path = "<string>"
        else:
            self.source_path = self.options.source_path

        ##

        try:
            read = grammar.read  ##

        except AttributeError:
            pass
        else:
            grammar = read()

        cache_fn = None
        cache_sha256 = None
        if isinstance(grammar, str):
            self.source_grammar = grammar
            if self.options.use_bytes:
                if not isascii(grammar):
                    raise ConfigurationError(
                        "Grammar must be ascii only, when use_bytes=True"
                    )

            if self.options.cache:
                if self.options.parser != "lalr":
                    raise ConfigurationError(
                        "cache only works with parser='lalr' for now"
                    )

                unhashable = (
                    "transformer",
                    "postlex",
                    "lexer_callbacks",
                    "edit_terminals",
                    "_plugins",
                )
                options_str = "".join(
                    k + str(v) for k, v in options.items() if k not in unhashable
                )
                from . import __version__

                s = grammar + options_str + __version__ + str(sys.version_info[:2])
                cache_sha256 = sha256_digest(s)

                if isinstance(self.options.cache, str):
                    cache_fn = self.options.cache
                else:
                    if self.options.cache is not True:
                        raise ConfigurationError("cache argument must be bool or str")

                    try:
                        username = getpass.getuser()
                    except Exception:
                        ##

                        ##

                        ##

                        username = "unknown"

                    cache_fn = (
                        tempfile.gettempdir()
                        + "/.lark_cache_%s_%s_%s_%s.tmp"
                        % (username, cache_sha256, *sys.version_info[:2])
                    )

                old_options = self.options
                try:
                    with FS.open(cache_fn, "rb") as f:
                        logger.debug("Loading grammar from cache: %s", cache_fn)
                        ##

                        for name in set(options) - _LOAD_ALLOWED_OPTIONS:
                            del options[name]
                        file_sha256 = f.readline().rstrip(b"\n")
                        cached_used_files = pickle.load(f)
                        if file_sha256 == cache_sha256.encode(
                            "utf8"
                        ) and verify_used_files(cached_used_files):
                            cached_parser_data = pickle.load(f)
                            self._load(cached_parser_data, **options)
                            return
                except FileNotFoundError:
                    ##

                    pass
                except (
                    Exception
                ):  ##

                    logger.exception(
                        "Failed to load Lark from cache: %r. We will try to carry on.",
                        cache_fn,
                    )

                    ##

                    ##

                    self.options = old_options

            ##

            self.grammar, used_files = load_grammar(
                grammar,
                self.source_path,
                self.options.import_paths,
                self.options.keep_all_tokens,
            )
        else:
            assert isinstance(grammar, Grammar)
            self.grammar = grammar

        if self.options.lexer == "auto":
            if self.options.parser == "lalr":
                self.options.lexer = "contextual"
            elif self.options.parser == "earley":
                if self.options.postlex is not None:
                    logger.info(
                        "postlex can't be used with the dynamic lexer, so we use 'basic' instead. "
                        "Consider using lalr with contextual instead of earley"
                    )
                    self.options.lexer = "basic"
                else:
                    self.options.lexer = "dynamic"
            elif self.options.parser == "cyk":
                self.options.lexer = "basic"
            else:
                assert False, self.options.parser
        lexer = self.options.lexer
        if isinstance(lexer, type):
            assert issubclass(
                lexer, Lexer
            )  ##

        else:
            assert_config(lexer, ("basic", "contextual", "dynamic", "dynamic_complete"))
            if self.options.postlex is not None and "dynamic" in lexer:
                raise ConfigurationError(
                    "Can't use postlex with a dynamic lexer. Use basic or contextual instead"
                )

        if self.options.ambiguity == "auto":
            if self.options.parser == "earley":
                self.options.ambiguity = "resolve"
        else:
            assert_config(
                self.options.parser,
                ("earley", "cyk"),
                "%r doesn't support disambiguation. Use one of these parsers instead: %s",
            )

        if self.options.priority == "auto":
            self.options.priority = "normal"

        if self.options.priority not in _VALID_PRIORITY_OPTIONS:
            raise ConfigurationError(
                "invalid priority option: %r. Must be one of %r"
                % (self.options.priority, _VALID_PRIORITY_OPTIONS)
            )
        if self.options.ambiguity not in _VALID_AMBIGUITY_OPTIONS:
            raise ConfigurationError(
                "invalid ambiguity option: %r. Must be one of %r"
                % (self.options.ambiguity, _VALID_AMBIGUITY_OPTIONS)
            )

        if self.options.parser is None:
            terminals_to_keep = "*"
        elif self.options.postlex is not None:
            terminals_to_keep = set(self.options.postlex.always_accept)
        else:
            terminals_to_keep = set()

        ##

        self.terminals, self.rules, self.ignore_tokens = self.grammar.compile(
            self.options.start, terminals_to_keep
        )

        if self.options.edit_terminals:
            for t in self.terminals:
                self.options.edit_terminals(t)

        self._terminals_dict = {t.name: t for t in self.terminals}

        ##

        if self.options.priority == "invert":
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = -rule.options.priority
            for term in self.terminals:
                term.priority = -term.priority
        ##

        ##

        ##

        elif self.options.priority is None:
            for rule in self.rules:
                if rule.options.priority is not None:
                    rule.options.priority = None
            for term in self.terminals:
                term.priority = 0

        ##

        self.lexer_conf = LexerConf(
            self.terminals,
            re_module,
            self.ignore_tokens,
            self.options.postlex,
            self.options.lexer_callbacks,
            self.options.g_regex_flags,
            use_bytes=self.options.use_bytes,
            strict=self.options.strict,
        )

        if self.options.parser:
            self.parser = self._build_parser()
        elif lexer:
            self.lexer = self._build_lexer()

        if cache_fn:
            logger.debug("Saving grammar to cache: %s", cache_fn)
            try:
                with FS.open(cache_fn, "wb") as f:
                    assert cache_sha256 is not None
                    f.write(cache_sha256.encode("utf8") + b"\n")
                    pickle.dump(used_files, f)
                    self.save(f, _LOAD_ALLOWED_OPTIONS)
            except IOError as e:
                logger.exception("Failed to save Lark to cache: %r.", cache_fn, e)

    if __doc__:
        __doc__ += "\n\n" + LarkOptions.OPTIONS_DOC

    __serialize_fields__ = "parser", "rules", "options"

    def _build_lexer(self, dont_ignore: bool = False) -> BasicLexer:
        lexer_conf = self.lexer_conf
        if dont_ignore:
            from copy import copy

            lexer_conf = copy(lexer_conf)
            lexer_conf.ignore = ()
        return BasicLexer(lexer_conf)

    def _prepare_callbacks(self) -> None:
        self._callbacks = {}
        ##

        if self.options.ambiguity != "forest":
            self._parse_tree_builder = ParseTreeBuilder(
                self.rules,
                self.options.tree_class or Tree,
                self.options.propagate_positions,
                self.options.parser != "lalr" and self.options.ambiguity == "explicit",
                self.options.maybe_placeholders,
            )
            self._callbacks = self._parse_tree_builder.create_callback(
                self.options.transformer
            )
        self._callbacks.update(
            _get_lexer_callbacks(self.options.transformer, self.terminals)
        )

    def _build_parser(self) -> "ParsingFrontend":
        self._prepare_callbacks()
        _validate_frontend_args(self.options.parser, self.options.lexer)
        parser_conf = ParserConf(self.rules, self._callbacks, self.options.start)
        return _construct_parsing_frontend(
            self.options.parser,
            self.options.lexer,
            self.lexer_conf,
            parser_conf,
            options=self.options,
        )

    def save(self, f, exclude_options: Collection[str] = ()) -> None:
        #--
        if self.options.parser != "lalr":
            raise NotImplementedError(
                "Lark.save() is only implemented for the LALR(1) parser."
            )
        data, m = self.memo_serialize([TerminalDef, Rule])
        if exclude_options:
            data["options"] = {
                n: v for n, v in data["options"].items() if n not in exclude_options
            }
        pickle.dump({"data": data, "memo": m}, f, protocol=pickle.HIGHEST_PROTOCOL)

    @classmethod
    def load(cls: Type[_T], f) -> _T:
        #--
        inst = cls.__new__(cls)
        return inst._load(f)

    def _deserialize_lexer_conf(
        self,
        data: Dict[str, Any],
        memo: Dict[int, Union[TerminalDef, Rule]],
        options: LarkOptions,
    ) -> LexerConf:
        lexer_conf = LexerConf.deserialize(data["lexer_conf"], memo)
        lexer_conf.callbacks = options.lexer_callbacks or {}
        lexer_conf.re_module = regex if options.regex else re
        lexer_conf.use_bytes = options.use_bytes
        lexer_conf.g_regex_flags = options.g_regex_flags
        lexer_conf.skip_validation = True
        lexer_conf.postlex = options.postlex
        return lexer_conf

    def _load(self: _T, f: Any, **kwargs) -> _T:
        if isinstance(f, dict):
            d = f
        else:
            d = pickle.load(f)
        memo_json = d["memo"]
        data = d["data"]

        assert memo_json
        memo = SerializeMemoizer.deserialize(
            memo_json, {"Rule": Rule, "TerminalDef": TerminalDef}, {}
        )
        options = dict(data["options"])
        if (set(kwargs) - _LOAD_ALLOWED_OPTIONS) & set(LarkOptions._defaults):
            raise ConfigurationError(
                "Some options are not allowed when loading a Parser: {}".format(
                    set(kwargs) - _LOAD_ALLOWED_OPTIONS
                )
            )
        options.update(kwargs)
        self.options = LarkOptions.deserialize(options, memo)
        self.rules = [Rule.deserialize(r, memo) for r in data["rules"]]
        self.source_path = "<deserialized>"
        _validate_frontend_args(self.options.parser, self.options.lexer)
        self.lexer_conf = self._deserialize_lexer_conf(
            data["parser"], memo, self.options
        )
        self.terminals = self.lexer_conf.terminals
        self._prepare_callbacks()
        self._terminals_dict = {t.name: t for t in self.terminals}
        self.parser = _deserialize_parsing_frontend(
            data["parser"],
            memo,
            self.lexer_conf,
            self._callbacks,
            self.options,  ##

        )
        return self

    @classmethod
    def _load_from_dict(cls, data, memo, **kwargs):
        inst = cls.__new__(cls)
        return inst._load({"data": data, "memo": memo}, **kwargs)

    @classmethod
    def open(
        cls: Type[_T], grammar_filename: str, rel_to: Optional[str] = None, **options
    ) -> _T:
        #--
        if rel_to:
            basepath = os.path.dirname(rel_to)
            grammar_filename = os.path.join(basepath, grammar_filename)
        with open(grammar_filename, encoding="utf8") as f:
            return cls(f, **options)

    @classmethod
    def open_from_package(
        cls: Type[_T],
        package: str,
        grammar_path: str,
        search_paths: "Sequence[str]" = [""],
        **options
    ) -> _T:
        #--
        package_loader = FromPackageLoader(package, search_paths)
        full_path, text = package_loader(None, grammar_path)
        options.setdefault("source_path", full_path)
        options.setdefault("import_paths", [])
        options["import_paths"].append(package_loader)
        return cls(text, **options)

    def __repr__(self):
        return "Lark(open(%r), parser=%r, lexer=%r, ...)" % (
            self.source_path,
            self.options.parser,
            self.options.lexer,
        )

    def lex(self, text: str, dont_ignore: bool = False) -> Iterator[Token]:
        #--
        lexer: Lexer
        if not hasattr(self, "lexer") or dont_ignore:
            lexer = self._build_lexer(dont_ignore)
        else:
            lexer = self.lexer
        lexer_thread = LexerThread.from_text(lexer, text)
        stream = lexer_thread.lex(None)
        if self.options.postlex:
            return self.options.postlex.process(stream)
        return stream

    def get_terminal(self, name: str) -> TerminalDef:
        #--
        return self._terminals_dict[name]

    def parse_interactive(
        self, text: Optional[str] = None, start: Optional[str] = None
    ) -> "InteractiveParser":
        #--
        return self.parser.parse_interactive(text, start=start)

    def parse(
        self,
        text: str,
        start: Optional[str] = None,
        on_error: "Optional[Callable[[UnexpectedInput], bool]]" = None,
    ) -> "ParseTree":
        #--
        return self.parser.parse(text, start=start, on_error=on_error)





class DedentError(LarkError):
    pass


class Indenter(PostLex, ABC):
    paren_level: int
    indent_level: List[int]

    def __init__(self) -> None:
        self.paren_level = 0
        self.indent_level = [0]
        assert self.tab_len > 0

    def handle_NL(self, token: Token) -> Iterator[Token]:
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit("\n", 1)[1]  ##

        indent = indent_str.count(" ") + indent_str.count("\t") * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            if indent != self.indent_level[-1]:
                raise DedentError(
                    "Unexpected dedent to column %s. Expected dedent to %s"
                    % (indent, self.indent_level[-1])
                )

    def _process(self, stream):
        for token in stream:
            if token.type == self.NL_type:
                yield from self.handle_NL(token)
            else:
                yield token

            if token.type in self.OPEN_PAREN_types:
                self.paren_level += 1
            elif token.type in self.CLOSE_PAREN_types:
                self.paren_level -= 1
                assert self.paren_level >= 0

        while len(self.indent_level) > 1:
            self.indent_level.pop()
            yield Token(self.DEDENT_type, "")

        assert self.indent_level == [0], self.indent_level

    def process(self, stream):
        self.paren_level = 0
        self.indent_level = [0]
        return self._process(stream)

    ##

    @property
    def always_accept(self):
        return (self.NL_type,)

    @property
    @abstractmethod
    def NL_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def OPEN_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def CLOSE_PAREN_types(self) -> List[str]:
        raise NotImplementedError()

    @property
    @abstractmethod
    def INDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def DEDENT_type(self) -> str:
        raise NotImplementedError()

    @property
    @abstractmethod
    def tab_len(self) -> int:
        raise NotImplementedError()


class PythonIndenter(Indenter):
    NL_type = "_NEWLINE"
    OPEN_PAREN_types = ["LPAR", "LSQB", "LBRACE"]
    CLOSE_PAREN_types = ["RPAR", "RSQB", "RBRACE"]
    INDENT_type = "_INDENT"
    DEDENT_type = "_DEDENT"
    tab_len = 8



import pickle, zlib, base64
DATA = (
b'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0B3oLnQPaoKmQuXQfZVhMPg8gGaqPMa8d94jviL6VTdCaSeWjTuxeNmJxctOLJp1YtGsE4vInVhC68SiZycW1DqxpNyJBdFOLCJ3Ynm0E8ujnVgo7sRiaSeW7DqxUNyJ5d+oaqHz0FjoApQLjYcKoBlQCVQElUIToUlQGTQFugi1QZcgOzQNioEuQ3HQFegqdA0aArmh4VAHNBK6DjVDVZAVaoXqoBtQNZQEjYGSoRToJnQLSocyoEwoC8qGcqB2qBIaB+VDeZANug0VQhOgYmgydAe6C92DmqCpUDl0H3oAzVR5jPkfn4tk3ufFMeautxGxvk+ukvnkKpmP8VUyCyLj9WrYXzLvUdNk/uC/No8iv+JR5DEL+99Fzh5nlouLnrzBUWTc1/9YJrAIPEY7lvhKIlmUE4qHlkILIRe0DGqEVkGJ0GpoNrQGWgulQuug9VAutATaAJVCJVARtBEqg+ZAXqgN2gRthuzQFqgT2gr5oAXQNmg75IZ2QDuhDmgWtAtaDrVCu6FqKAnaA62A0qEMKBPaC82HPNA8KBtaCS2G2qE8aBFkg+ZChdA+qAvyQ03QfugAdBA6BB2GjkBHoWPQcSgAnYBOQt3QKSgInYYqoAaoGaqC6qAaKA3KgmqhHKgSyofKVR5jcST89l8i9V35n0ThVpxRNCocigZFs6JKUaeoUVQr0hRZilpFjqJSka+YoShWNCnKFTMVPYpexVlFSPGyIlYxSHFOMVgRrxiqGKEYpkhQJCpGKUYrUhXnFWMVFxS5ivGKAkWJokhRqpiomKQoU0xRXFS0KS4p7IppihjFZUWc4oriquKaYohiuKJDMVJxXWFVtCpuKJIUYxTJihTFTcUtRboiQ5GpyFa0K8Yp8hQ2xW1FoWKCYrLijuKu4p5iquK+4oHAE67szJgXrjnqvT5Jt83aY7WZ8PYno04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04ko04k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EOtAuHcgGDui4TcHF9r8q7waUbQpXlI4FfGKpYqFCpdimaJRsUqRqFitmK1Yo1irSFWsU6xX5CqWKDYoShUliiLFRkWZYo7Cq9ik2KywK7YoOhVbFT7FNsV2hVuxQ7FT0aGYpdilWK5oVexWVCuSFHsUKxTpigxFpmKvYr7Co8hWrFQsVrQr8hSLFDbFXEWhYp+iS+FXNCn2Kw4oLIpDigrFYUWD4qiiRpGmCChqFacVBxVHFM2KKkWd4pjiuOKEIkuRozipqFTkK7oVpxTliqDAY4zFezAVYAG/AAuBBVj6K8BiXwGW7AuwBBvVGagRckAzoAaoGSqGqqA6qAaqhpqgNKgcyoJmQj1QL3QWCkEvQ7HQIOgcNAJKgBKhUdBo6AJUAk2EyqAp0CUoBroMdUDXoVboBpQEJUMpUDqUAWVCt6EJ0GToDnQXGgzFQ0OhYVAqdB4aC+VC46ECqAgqhSZBF6E2yA5Ng+KgK9BV6Bo0BBoOjYSs0BjoJnQLyobaoXFQHmSDCqF70FToPvRA5THGmbtPzVvX50d2n+ZiKaAFBWkLCtIWFKQtWApoQXnagvK0BeVpC8rTFiwFtKBYbUGx2oJitQXFagsK/BaUri0oXVtQuragdG1B6dqC0rUFpWsLStcWlK4tKF1bULq2YFmiBYVsCwrZFiw9tGDpoQVFbguWHlpQ8rag5G1ByduCkrcFJW8LSt4WlLwtKHlbUPK2oOSNahe0HGqFdkPVUBK0B1oBpUMZUCa0F5oPeaB5UDa0EloMtUN50CLIBs2FCqF9UBfkh5qg/dAB6BB0GDoKBaDT0EHoCHQMOg6dgE5C3dApKAjVQjlQJZQPVUANUDNUBdVBNVAaVA5lqTzG+Ej47S/4H8nZFoHHyEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMObEMO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UYW1ogprRRXWiiqsFVVYK6qwVqwZWlGTtWIF0YoKrRUVWisqtFasNVqx1mjFWqMVtVwrVh6tqOxasQ5pxTqkFVVfK6q+VqxRWrFGacUapRX1YSvqw4RyoEaoDBoO5UG5UD50GSqARkNF0HjoCnQVugZ5oIlQKXQdugFNlwpq/xoPgMYdSDLUoMu1UGKLwKXGYvqplvJ21VJWTfkfoZWvuuBtyaFEe/1yUkg09zs73EHtF+ry5sU6v5ykLm/+ZfwHqq2bM6HEhsEu9Y2d9fB/jf8jV0MboU3QDOgFaDlUCM2EtkFboDqoAloBrYTCUBr0ElQPrYLWQjuhrVAmtB6aCy2C5kEN0CxoMVQLNUFLoKXQHCgIBaBl0AKoEVoIzYdmQ36poParJ7cr+c7dyM5dyk/GrqSxGWlsT360u5JqU+xLoY/BcNfP9H/gV0Mfxi7lfP1PLfS+dyuNTUpj2/Jd7VaqG8UeCH3Iu5W/VjlGvce+lqJyzH81bl36laTQg/i6IFHz/ze0Y1xox7jQjnGhHeNCO8aFdowL7RgX2jEutGNcaMe40I5xoR3jQjvGhXaMC+0YF9oxLrRjXGjHuNCOcaEd40I7xoV2jAvtGBfaMS60Y1xox7jQjnGhHeNCO8aFdowL7RgX2jEutGNcaMe40I5xoR3jQjvGhXaMC+0YF9oxLrRjXGjHuNCOcaEd40I7xoV2jAvtGBfaMS60Y1xox7jQjnGhHeNCO8aFdowL7RgX2jEutGNcaMe40I5xoR3jQjvGhXaMCw0YFxowLjRgXGjAuNCAcaHl4kLLxYWWiwstFxdaLi60XFxoubjQcnGh5eJCy8WFlosLLRcXWi4utFxcaLm40HJxoeXiQsvFhZaLCy0XF1ouLrRcXGi5uNBycaHl4kLLxYWWiwstFxdaLi60XFxoubjQcnGh5eJKhN///jEsuYynYD+p2ktdVeP82BdhT33x9dSPhr3PYuuDL7KC+u9GlkselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEselEueRLn0/yL8xhB+Ywi/MYTfGMJvDOE3hvAbQ/iNIfzGEH5jCL8xhN8Ywm8M4TeG8BtD+I0h/MYQfmMIvzGE3xjCbwzhN4bwG0P4jSH8xhB+Ywi/MYTfGMJvDOE3hvAbQ/iNIfzGEH5jCL8xhN8Ywm8M4TeG8BtD+I0h/MYQfmMIvzGE3xjCbwzhN4bwG0P4jSH8xhB+Ywi/MYTfGMJvDOE3hvAbQ/iNIfzGEH5jCL8xhN8Ywm8M4TeG8BtD+I0h/MYQfmMIvzGE3xjCbwzhN4bwG0P4jSH8xhA4YwiAMYTmGEJzDCE2hlAZQ9iOIXDGEIxjCKMxhOYYwn0MgTqG4B9DGI0hjMYQHGMIjjGE7RgCbgwBN4aAG0MYjSHcxxDuYwj3MQTjhExQEpQC9YDMkBXqCdmgXlBvqA/UF+oH9YcGQAOhQdBgaBg0HBoJjYKKoBJoLDQemgBNhCZLBfUFoEyKtfEveR6yQIugedAsaDFUC70ApULLoZnQCmglNAR6EVoFjYAWQquhYmgMVAitgcZBfuglqB5aC70MTYLWQa9A66EQNBfaAG2EGqBXoU1QEzQD2gwtgeqgLVAFlAaFoaXQUCgDyoS2QnOgIBSAsqFl0AKoEcqF5kP50GyoAHoN2gZthzzQDmgntAvaDe2F9kNRqBnaA7VA+6ADUAQ6CB2CDkPToByoDMqDpkA1kBcqh6qgSigdKoWypILa/3zEM3iMLuuTehjPO++T0tl1M5ptj7709+P40Ol39SiQJ/Vsnp/oX/WnoaflGT1GJ/LJP6znf/Fen0myaEjIAi2C5kGzoMVQLfQClAoth2ZCK6CV0BDoRWgVNAJaCK2GiqExUCG0BhoH+aGXoHpoLfQyNAlaB70CrYdC0FxoA7QRaoBehTZBTdAMaDO0BKqDtkAVUBoUhpZCQ6EMKBPaCs2BglAAyoaWQQugRigXmg/lQ7OhAug1aBu0HfJAO6Cd0BRoL1QJpUP7oSjUDO2BqqADUA5UBh2GkqFd0G6o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'
)
DATA = pickle.loads(zlib.decompress(base64.b64decode(DATA)))
MEMO = (
b'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'
)
MEMO = pickle.loads(zlib.decompress(base64.b64decode(MEMO)))
Shift = 0
Reduce = 1
def Lark_StandAlone(**kwargs):
  return Lark._load_from_dict(DATA, MEMO, **kwargs)
