# coding: utf-8

"""
    Fireblocks API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.6.2
    Contact: support@fireblocks.com
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from fireblocks_client import schemas  # noqa: F401


class PolicyRule(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Policy rule which is enforced on transactions
    """


    class MetaOapg:
        required = {
            "externalDescriptor",
            "amount",
            "periodSec",
            "action",
            "asset",
            "type",
            "amountScope",
            "amountCurrency",
        }
        
        class properties:
            
            
            class type(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "TRANSFER": "TRANSFER",
                    }
                
                @schemas.classproperty
                def TRANSFER(cls):
                    return cls("TRANSFER")
            
            
            class action(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "ALLOW": "ALLOW",
                        "BLOCK": "BLOCK",
                        "2-TIER": "TIER",
                    }
                
                @schemas.classproperty
                def ALLOW(cls):
                    return cls("ALLOW")
                
                @schemas.classproperty
                def BLOCK(cls):
                    return cls("BLOCK")
                
                @schemas.classproperty
                def TIER(cls):
                    return cls("2-TIER")
            asset = schemas.StrSchema
            
            
            class amountCurrency(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "USD": "USD",
                        "EUR": "EUR",
                        "NATIVE": "NATIVE",
                    }
                
                @schemas.classproperty
                def USD(cls):
                    return cls("USD")
                
                @schemas.classproperty
                def EUR(cls):
                    return cls("EUR")
                
                @schemas.classproperty
                def NATIVE(cls):
                    return cls("NATIVE")
            
            
            class amountScope(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "SINGLE_TX": "SINGLE_TX",
                        "TIMEFRAME": "TIMEFRAME",
                    }
                
                @schemas.classproperty
                def SINGLE_TX(cls):
                    return cls("SINGLE_TX")
                
                @schemas.classproperty
                def TIMEFRAME(cls):
                    return cls("TIMEFRAME")
            amount = schemas.NumberSchema
            periodSec = schemas.NumberSchema
            externalDescriptor = schemas.StrSchema
            operator = schemas.StrSchema
            
            
            class operators(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        
                        
                        class wildcard(
                            schemas.EnumBase,
                            schemas.StrSchema
                        ):
                        
                        
                            class MetaOapg:
                                enum_value_to_name = {
                                    "*": "ASTERISK",
                                }
                            
                            @schemas.classproperty
                            def ASTERISK(cls):
                                return cls("*")
                        
                        
                        class users(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                items = schemas.StrSchema
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'users':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        
                        
                        class usersGroups(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                items = schemas.StrSchema
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'usersGroups':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        
                        
                        class services(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                items = schemas.StrSchema
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'services':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        __annotations__ = {
                            "wildcard": wildcard,
                            "users": users,
                            "usersGroups": usersGroups,
                            "services": services,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["wildcard"]) -> MetaOapg.properties.wildcard: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["usersGroups"]) -> MetaOapg.properties.usersGroups: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["services"]) -> MetaOapg.properties.services: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["wildcard", "users", "usersGroups", "services", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["wildcard"]) -> typing.Union[MetaOapg.properties.wildcard, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["users"]) -> typing.Union[MetaOapg.properties.users, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["usersGroups"]) -> typing.Union[MetaOapg.properties.usersGroups, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["services"]) -> typing.Union[MetaOapg.properties.services, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["wildcard", "users", "usersGroups", "services", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    wildcard: typing.Union[MetaOapg.properties.wildcard, str, schemas.Unset] = schemas.unset,
                    users: typing.Union[MetaOapg.properties.users, list, tuple, schemas.Unset] = schemas.unset,
                    usersGroups: typing.Union[MetaOapg.properties.usersGroups, list, tuple, schemas.Unset] = schemas.unset,
                    services: typing.Union[MetaOapg.properties.services, list, tuple, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'operators':
                    return super().__new__(
                        cls,
                        *_args,
                        wildcard=wildcard,
                        users=users,
                        usersGroups=usersGroups,
                        services=services,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class transactionType(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "TRANSFER": "TRANSFER",
                        "CONTRACT_CALL": "CONTRACT_CALL",
                        "APPROVE": "APPROVE",
                        "MINT": "MINT",
                        "BURN": "BURN",
                        "SUPPLY": "SUPPLY",
                        "REDEEM": "REDEEM",
                        "STAKE": "STAKE",
                        "RAW": "RAW",
                        "TYPED_MESSAGE": "TYPED_MESSAGE",
                    }
                
                @schemas.classproperty
                def TRANSFER(cls):
                    return cls("TRANSFER")
                
                @schemas.classproperty
                def CONTRACT_CALL(cls):
                    return cls("CONTRACT_CALL")
                
                @schemas.classproperty
                def APPROVE(cls):
                    return cls("APPROVE")
                
                @schemas.classproperty
                def MINT(cls):
                    return cls("MINT")
                
                @schemas.classproperty
                def BURN(cls):
                    return cls("BURN")
                
                @schemas.classproperty
                def SUPPLY(cls):
                    return cls("SUPPLY")
                
                @schemas.classproperty
                def REDEEM(cls):
                    return cls("REDEEM")
                
                @schemas.classproperty
                def STAKE(cls):
                    return cls("STAKE")
                
                @schemas.classproperty
                def RAW(cls):
                    return cls("RAW")
                
                @schemas.classproperty
                def TYPED_MESSAGE(cls):
                    return cls("TYPED_MESSAGE")
            designatedSigner = schemas.StrSchema
            
            
            class designatedSigners(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        
                        
                        class users(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                items = schemas.StrSchema
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'users':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        
                        
                        class usersGroups(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                items = schemas.StrSchema
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'usersGroups':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        __annotations__ = {
                            "users": users,
                            "usersGroups": usersGroups,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["usersGroups"]) -> MetaOapg.properties.usersGroups: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["users", "usersGroups", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["users"]) -> typing.Union[MetaOapg.properties.users, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["usersGroups"]) -> typing.Union[MetaOapg.properties.usersGroups, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["users", "usersGroups", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    users: typing.Union[MetaOapg.properties.users, list, tuple, schemas.Unset] = schemas.unset,
                    usersGroups: typing.Union[MetaOapg.properties.usersGroups, list, tuple, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'designatedSigners':
                    return super().__new__(
                        cls,
                        *_args,
                        users=users,
                        usersGroups=usersGroups,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class srcType(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            PolicySrcOrDestType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'srcType':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class srcSubType(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            PolicySrcOrDestSubType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'srcSubType':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class srcId(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    all_of_0 = schemas.StrSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.all_of_0,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'srcId':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class src(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        
                        
                        class ids(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                
                                
                                class items(
                                    schemas.ListSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        max_items = 3
                                        min_items = 1
                                        
                                        
                                        class items(
                                            schemas.ComposedSchema,
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                one_of_0 = schemas.StrSchema
                                                
                                                @classmethod
                                                @functools.lru_cache()
                                                def one_of(cls):
                                                    # we need this here to make our import statements work
                                                    # we must store _composed_schemas in here so the code is only run
                                                    # when we invoke this method. If we kept this at the class
                                                    # level we would get an error because the class level
                                                    # code would be run when this module is imported, and these composed
                                                    # classes don't exist yet because their module has not finished
                                                    # loading
                                                    return [
                                                        cls.one_of_0,
                                                        PolicySrcOrDestType,
                                                        PolicySrcOrDestSubType,
                                                    ]
                                        
                                        
                                            def __new__(
                                                cls,
                                                *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                            ) -> 'items':
                                                return super().__new__(
                                                    cls,
                                                    *_args,
                                                    _configuration=_configuration,
                                                    **kwargs,
                                                )
                                
                                    def __new__(
                                        cls,
                                        _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                    ) -> 'items':
                                        return super().__new__(
                                            cls,
                                            _arg,
                                            _configuration=_configuration,
                                        )
                                
                                    def __getitem__(self, i: int) -> MetaOapg.items:
                                        return super().__getitem__(i)
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, list, tuple, ]], typing.List[typing.Union[MetaOapg.items, list, tuple, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'ids':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        __annotations__ = {
                            "ids": ids,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["ids"]) -> MetaOapg.properties.ids: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["ids", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["ids"]) -> typing.Union[MetaOapg.properties.ids, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["ids", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    ids: typing.Union[MetaOapg.properties.ids, list, tuple, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'src':
                    return super().__new__(
                        cls,
                        *_args,
                        ids=ids,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class dstType(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            PolicySrcOrDestType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'dstType':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class dstSubType(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            PolicySrcOrDestSubType,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'dstSubType':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class dstId(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    all_of_0 = schemas.StrSchema
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.all_of_0,
                        ]
            
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'dstId':
                    return super().__new__(
                        cls,
                        *_args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class dst(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        
                        
                        class ids(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                
                                
                                class items(
                                    schemas.ListSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        max_items = 3
                                        min_items = 1
                                        
                                        
                                        class items(
                                            schemas.ComposedSchema,
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                one_of_0 = schemas.StrSchema
                                                
                                                @classmethod
                                                @functools.lru_cache()
                                                def one_of(cls):
                                                    # we need this here to make our import statements work
                                                    # we must store _composed_schemas in here so the code is only run
                                                    # when we invoke this method. If we kept this at the class
                                                    # level we would get an error because the class level
                                                    # code would be run when this module is imported, and these composed
                                                    # classes don't exist yet because their module has not finished
                                                    # loading
                                                    return [
                                                        cls.one_of_0,
                                                        PolicySrcOrDestType,
                                                        PolicySrcOrDestSubType,
                                                    ]
                                        
                                        
                                            def __new__(
                                                cls,
                                                *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                            ) -> 'items':
                                                return super().__new__(
                                                    cls,
                                                    *_args,
                                                    _configuration=_configuration,
                                                    **kwargs,
                                                )
                                
                                    def __new__(
                                        cls,
                                        _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                    ) -> 'items':
                                        return super().__new__(
                                            cls,
                                            _arg,
                                            _configuration=_configuration,
                                        )
                                
                                    def __getitem__(self, i: int) -> MetaOapg.items:
                                        return super().__getitem__(i)
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, list, tuple, ]], typing.List[typing.Union[MetaOapg.items, list, tuple, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'ids':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        __annotations__ = {
                            "ids": ids,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["ids"]) -> MetaOapg.properties.ids: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["ids", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["ids"]) -> typing.Union[MetaOapg.properties.ids, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["ids", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    ids: typing.Union[MetaOapg.properties.ids, list, tuple, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'dst':
                    return super().__new__(
                        cls,
                        *_args,
                        ids=ids,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class dstAddressType(
                schemas.EnumBase,
                schemas.StrSchema
            ):
            
            
                class MetaOapg:
                    enum_value_to_name = {
                        "WHITELISTED": "WHITELISTED",
                        "ONE_TIME": "ONE_TIME",
                        "*": "ASTERISK",
                    }
                
                @schemas.classproperty
                def WHITELISTED(cls):
                    return cls("WHITELISTED")
                
                @schemas.classproperty
                def ONE_TIME(cls):
                    return cls("ONE_TIME")
                
                @schemas.classproperty
                def ASTERISK(cls):
                    return cls("*")
            
            
            class authorizers(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.StrSchema
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'authorizers':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            authorizersCount = schemas.NumberSchema
            
            
            class authorizationGroups(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        
                        
                        class logic(
                            schemas.EnumBase,
                            schemas.StrSchema
                        ):
                        
                        
                            class MetaOapg:
                                enum_value_to_name = {
                                    "AND": "AND",
                                    "OR": "OR",
                                }
                            
                            @schemas.classproperty
                            def AND(cls):
                                return cls("AND")
                            
                            @schemas.classproperty
                            def OR(cls):
                                return cls("OR")
                        allowOperatorAsAuthorizer = schemas.BoolSchema
                        
                        
                        class groups(
                            schemas.ListSchema
                        ):
                        
                        
                            class MetaOapg:
                                
                                
                                class items(
                                    schemas.DictSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        
                                        class properties:
                                            
                                            
                                            class users(
                                                schemas.ListSchema
                                            ):
                                            
                                            
                                                class MetaOapg:
                                                    items = schemas.StrSchema
                                            
                                                def __new__(
                                                    cls,
                                                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                                ) -> 'users':
                                                    return super().__new__(
                                                        cls,
                                                        _arg,
                                                        _configuration=_configuration,
                                                    )
                                            
                                                def __getitem__(self, i: int) -> MetaOapg.items:
                                                    return super().__getitem__(i)
                                            
                                            
                                            class usersGroups(
                                                schemas.ListSchema
                                            ):
                                            
                                            
                                                class MetaOapg:
                                                    items = schemas.StrSchema
                                            
                                                def __new__(
                                                    cls,
                                                    _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                                                    _configuration: typing.Optional[schemas.Configuration] = None,
                                                ) -> 'usersGroups':
                                                    return super().__new__(
                                                        cls,
                                                        _arg,
                                                        _configuration=_configuration,
                                                    )
                                            
                                                def __getitem__(self, i: int) -> MetaOapg.items:
                                                    return super().__getitem__(i)
                                            th = schemas.NumberSchema
                                            __annotations__ = {
                                                "users": users,
                                                "usersGroups": usersGroups,
                                                "th": th,
                                            }
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["usersGroups"]) -> MetaOapg.properties.usersGroups: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: typing_extensions.Literal["th"]) -> MetaOapg.properties.th: ...
                                    
                                    @typing.overload
                                    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                    
                                    def __getitem__(self, name: typing.Union[typing_extensions.Literal["users", "usersGroups", "th", ], str]):
                                        # dict_instance[name] accessor
                                        return super().__getitem__(name)
                                    
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["users"]) -> typing.Union[MetaOapg.properties.users, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["usersGroups"]) -> typing.Union[MetaOapg.properties.usersGroups, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: typing_extensions.Literal["th"]) -> typing.Union[MetaOapg.properties.th, schemas.Unset]: ...
                                    
                                    @typing.overload
                                    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                    
                                    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["users", "usersGroups", "th", ], str]):
                                        return super().get_item_oapg(name)
                                    
                                
                                    def __new__(
                                        cls,
                                        *_args: typing.Union[dict, frozendict.frozendict, ],
                                        users: typing.Union[MetaOapg.properties.users, list, tuple, schemas.Unset] = schemas.unset,
                                        usersGroups: typing.Union[MetaOapg.properties.usersGroups, list, tuple, schemas.Unset] = schemas.unset,
                                        th: typing.Union[MetaOapg.properties.th, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                    ) -> 'items':
                                        return super().__new__(
                                            cls,
                                            *_args,
                                            users=users,
                                            usersGroups=usersGroups,
                                            th=th,
                                            _configuration=_configuration,
                                            **kwargs,
                                        )
                        
                            def __new__(
                                cls,
                                _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, ]]],
                                _configuration: typing.Optional[schemas.Configuration] = None,
                            ) -> 'groups':
                                return super().__new__(
                                    cls,
                                    _arg,
                                    _configuration=_configuration,
                                )
                        
                            def __getitem__(self, i: int) -> MetaOapg.items:
                                return super().__getitem__(i)
                        __annotations__ = {
                            "logic": logic,
                            "allowOperatorAsAuthorizer": allowOperatorAsAuthorizer,
                            "groups": groups,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["logic"]) -> MetaOapg.properties.logic: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["allowOperatorAsAuthorizer"]) -> MetaOapg.properties.allowOperatorAsAuthorizer: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["groups"]) -> MetaOapg.properties.groups: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["logic", "allowOperatorAsAuthorizer", "groups", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["logic"]) -> typing.Union[MetaOapg.properties.logic, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["allowOperatorAsAuthorizer"]) -> typing.Union[MetaOapg.properties.allowOperatorAsAuthorizer, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["groups"]) -> typing.Union[MetaOapg.properties.groups, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["logic", "allowOperatorAsAuthorizer", "groups", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    logic: typing.Union[MetaOapg.properties.logic, str, schemas.Unset] = schemas.unset,
                    allowOperatorAsAuthorizer: typing.Union[MetaOapg.properties.allowOperatorAsAuthorizer, bool, schemas.Unset] = schemas.unset,
                    groups: typing.Union[MetaOapg.properties.groups, list, tuple, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'authorizationGroups':
                    return super().__new__(
                        cls,
                        *_args,
                        logic=logic,
                        allowOperatorAsAuthorizer=allowOperatorAsAuthorizer,
                        groups=groups,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class amountAggregation(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                    
                        @staticmethod
                        def operators() -> typing.Type['AmountAggregationTimePeriodMethod']:
                            return AmountAggregationTimePeriodMethod
                    
                        @staticmethod
                        def srcTransferPeers() -> typing.Type['AmountAggregationTimePeriodMethod']:
                            return AmountAggregationTimePeriodMethod
                    
                        @staticmethod
                        def dstTransferPeers() -> typing.Type['AmountAggregationTimePeriodMethod']:
                            return AmountAggregationTimePeriodMethod
                        __annotations__ = {
                            "operators": operators,
                            "srcTransferPeers": srcTransferPeers,
                            "dstTransferPeers": dstTransferPeers,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["operators"]) -> 'AmountAggregationTimePeriodMethod': ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["srcTransferPeers"]) -> 'AmountAggregationTimePeriodMethod': ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["dstTransferPeers"]) -> 'AmountAggregationTimePeriodMethod': ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["operators", "srcTransferPeers", "dstTransferPeers", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["operators"]) -> typing.Union['AmountAggregationTimePeriodMethod', schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["srcTransferPeers"]) -> typing.Union['AmountAggregationTimePeriodMethod', schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["dstTransferPeers"]) -> typing.Union['AmountAggregationTimePeriodMethod', schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["operators", "srcTransferPeers", "dstTransferPeers", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    operators: typing.Union['AmountAggregationTimePeriodMethod', schemas.Unset] = schemas.unset,
                    srcTransferPeers: typing.Union['AmountAggregationTimePeriodMethod', schemas.Unset] = schemas.unset,
                    dstTransferPeers: typing.Union['AmountAggregationTimePeriodMethod', schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'amountAggregation':
                    return super().__new__(
                        cls,
                        *_args,
                        operators=operators,
                        srcTransferPeers=srcTransferPeers,
                        dstTransferPeers=dstTransferPeers,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class rawMessageSigning(
                schemas.DictSchema
            ):
            
            
                class MetaOapg:
                    
                    class properties:
                        algorithm = schemas.StrSchema
                        
                        
                        class derivationPath(
                            schemas.DictSchema
                        ):
                        
                        
                            class MetaOapg:
                                
                                class properties:
                                    
                                    
                                    class path(
                                        schemas.ListSchema
                                    ):
                                    
                                    
                                        class MetaOapg:
                                            items = schemas.NumberSchema
                                    
                                        def __new__(
                                            cls,
                                            _arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, float, ]]],
                                            _configuration: typing.Optional[schemas.Configuration] = None,
                                        ) -> 'path':
                                            return super().__new__(
                                                cls,
                                                _arg,
                                                _configuration=_configuration,
                                            )
                                    
                                        def __getitem__(self, i: int) -> MetaOapg.items:
                                            return super().__getitem__(i)
                                    __annotations__ = {
                                        "path": path,
                                    }
                            
                            @typing.overload
                            def __getitem__(self, name: typing_extensions.Literal["path"]) -> MetaOapg.properties.path: ...
                            
                            @typing.overload
                            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                            
                            def __getitem__(self, name: typing.Union[typing_extensions.Literal["path", ], str]):
                                # dict_instance[name] accessor
                                return super().__getitem__(name)
                            
                            
                            @typing.overload
                            def get_item_oapg(self, name: typing_extensions.Literal["path"]) -> typing.Union[MetaOapg.properties.path, schemas.Unset]: ...
                            
                            @typing.overload
                            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                            
                            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["path", ], str]):
                                return super().get_item_oapg(name)
                            
                        
                            def __new__(
                                cls,
                                *_args: typing.Union[dict, frozendict.frozendict, ],
                                path: typing.Union[MetaOapg.properties.path, list, tuple, schemas.Unset] = schemas.unset,
                                _configuration: typing.Optional[schemas.Configuration] = None,
                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                            ) -> 'derivationPath':
                                return super().__new__(
                                    cls,
                                    *_args,
                                    path=path,
                                    _configuration=_configuration,
                                    **kwargs,
                                )
                        __annotations__ = {
                            "algorithm": algorithm,
                            "derivationPath": derivationPath,
                        }
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["algorithm"]) -> MetaOapg.properties.algorithm: ...
                
                @typing.overload
                def __getitem__(self, name: typing_extensions.Literal["derivationPath"]) -> MetaOapg.properties.derivationPath: ...
                
                @typing.overload
                def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                
                def __getitem__(self, name: typing.Union[typing_extensions.Literal["algorithm", "derivationPath", ], str]):
                    # dict_instance[name] accessor
                    return super().__getitem__(name)
                
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["algorithm"]) -> typing.Union[MetaOapg.properties.algorithm, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: typing_extensions.Literal["derivationPath"]) -> typing.Union[MetaOapg.properties.derivationPath, schemas.Unset]: ...
                
                @typing.overload
                def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                
                def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["algorithm", "derivationPath", ], str]):
                    return super().get_item_oapg(name)
                
            
                def __new__(
                    cls,
                    *_args: typing.Union[dict, frozendict.frozendict, ],
                    algorithm: typing.Union[MetaOapg.properties.algorithm, str, schemas.Unset] = schemas.unset,
                    derivationPath: typing.Union[MetaOapg.properties.derivationPath, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'rawMessageSigning':
                    return super().__new__(
                        cls,
                        *_args,
                        algorithm=algorithm,
                        derivationPath=derivationPath,
                        _configuration=_configuration,
                        **kwargs,
                    )
            applyForApprove = schemas.BoolSchema
            applyForTypedMessage = schemas.BoolSchema
            __annotations__ = {
                "type": type,
                "action": action,
                "asset": asset,
                "amountCurrency": amountCurrency,
                "amountScope": amountScope,
                "amount": amount,
                "periodSec": periodSec,
                "externalDescriptor": externalDescriptor,
                "operator": operator,
                "operators": operators,
                "transactionType": transactionType,
                "designatedSigner": designatedSigner,
                "designatedSigners": designatedSigners,
                "srcType": srcType,
                "srcSubType": srcSubType,
                "srcId": srcId,
                "src": src,
                "dstType": dstType,
                "dstSubType": dstSubType,
                "dstId": dstId,
                "dst": dst,
                "dstAddressType": dstAddressType,
                "authorizers": authorizers,
                "authorizersCount": authorizersCount,
                "authorizationGroups": authorizationGroups,
                "amountAggregation": amountAggregation,
                "rawMessageSigning": rawMessageSigning,
                "applyForApprove": applyForApprove,
                "applyForTypedMessage": applyForTypedMessage,
            }
    
    externalDescriptor: MetaOapg.properties.externalDescriptor
    amount: MetaOapg.properties.amount
    periodSec: MetaOapg.properties.periodSec
    action: MetaOapg.properties.action
    asset: MetaOapg.properties.asset
    type: MetaOapg.properties.type
    amountScope: MetaOapg.properties.amountScope
    amountCurrency: MetaOapg.properties.amountCurrency
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["action"]) -> MetaOapg.properties.action: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["asset"]) -> MetaOapg.properties.asset: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amountCurrency"]) -> MetaOapg.properties.amountCurrency: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amountScope"]) -> MetaOapg.properties.amountScope: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amount"]) -> MetaOapg.properties.amount: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["periodSec"]) -> MetaOapg.properties.periodSec: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["externalDescriptor"]) -> MetaOapg.properties.externalDescriptor: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["operator"]) -> MetaOapg.properties.operator: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["operators"]) -> MetaOapg.properties.operators: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["transactionType"]) -> MetaOapg.properties.transactionType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["designatedSigner"]) -> MetaOapg.properties.designatedSigner: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["designatedSigners"]) -> MetaOapg.properties.designatedSigners: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["srcType"]) -> MetaOapg.properties.srcType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["srcSubType"]) -> MetaOapg.properties.srcSubType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["srcId"]) -> MetaOapg.properties.srcId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["src"]) -> MetaOapg.properties.src: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dstType"]) -> MetaOapg.properties.dstType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dstSubType"]) -> MetaOapg.properties.dstSubType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dstId"]) -> MetaOapg.properties.dstId: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dst"]) -> MetaOapg.properties.dst: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["dstAddressType"]) -> MetaOapg.properties.dstAddressType: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["authorizers"]) -> MetaOapg.properties.authorizers: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["authorizersCount"]) -> MetaOapg.properties.authorizersCount: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["authorizationGroups"]) -> MetaOapg.properties.authorizationGroups: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["amountAggregation"]) -> MetaOapg.properties.amountAggregation: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["rawMessageSigning"]) -> MetaOapg.properties.rawMessageSigning: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["applyForApprove"]) -> MetaOapg.properties.applyForApprove: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["applyForTypedMessage"]) -> MetaOapg.properties.applyForTypedMessage: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["type", "action", "asset", "amountCurrency", "amountScope", "amount", "periodSec", "externalDescriptor", "operator", "operators", "transactionType", "designatedSigner", "designatedSigners", "srcType", "srcSubType", "srcId", "src", "dstType", "dstSubType", "dstId", "dst", "dstAddressType", "authorizers", "authorizersCount", "authorizationGroups", "amountAggregation", "rawMessageSigning", "applyForApprove", "applyForTypedMessage", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["action"]) -> MetaOapg.properties.action: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["asset"]) -> MetaOapg.properties.asset: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amountCurrency"]) -> MetaOapg.properties.amountCurrency: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amountScope"]) -> MetaOapg.properties.amountScope: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amount"]) -> MetaOapg.properties.amount: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["periodSec"]) -> MetaOapg.properties.periodSec: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["externalDescriptor"]) -> MetaOapg.properties.externalDescriptor: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["operator"]) -> typing.Union[MetaOapg.properties.operator, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["operators"]) -> typing.Union[MetaOapg.properties.operators, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["transactionType"]) -> typing.Union[MetaOapg.properties.transactionType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["designatedSigner"]) -> typing.Union[MetaOapg.properties.designatedSigner, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["designatedSigners"]) -> typing.Union[MetaOapg.properties.designatedSigners, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["srcType"]) -> typing.Union[MetaOapg.properties.srcType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["srcSubType"]) -> typing.Union[MetaOapg.properties.srcSubType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["srcId"]) -> typing.Union[MetaOapg.properties.srcId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["src"]) -> typing.Union[MetaOapg.properties.src, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dstType"]) -> typing.Union[MetaOapg.properties.dstType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dstSubType"]) -> typing.Union[MetaOapg.properties.dstSubType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dstId"]) -> typing.Union[MetaOapg.properties.dstId, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dst"]) -> typing.Union[MetaOapg.properties.dst, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["dstAddressType"]) -> typing.Union[MetaOapg.properties.dstAddressType, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["authorizers"]) -> typing.Union[MetaOapg.properties.authorizers, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["authorizersCount"]) -> typing.Union[MetaOapg.properties.authorizersCount, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["authorizationGroups"]) -> typing.Union[MetaOapg.properties.authorizationGroups, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["amountAggregation"]) -> typing.Union[MetaOapg.properties.amountAggregation, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["rawMessageSigning"]) -> typing.Union[MetaOapg.properties.rawMessageSigning, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["applyForApprove"]) -> typing.Union[MetaOapg.properties.applyForApprove, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["applyForTypedMessage"]) -> typing.Union[MetaOapg.properties.applyForTypedMessage, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["type", "action", "asset", "amountCurrency", "amountScope", "amount", "periodSec", "externalDescriptor", "operator", "operators", "transactionType", "designatedSigner", "designatedSigners", "srcType", "srcSubType", "srcId", "src", "dstType", "dstSubType", "dstId", "dst", "dstAddressType", "authorizers", "authorizersCount", "authorizationGroups", "amountAggregation", "rawMessageSigning", "applyForApprove", "applyForTypedMessage", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        externalDescriptor: typing.Union[MetaOapg.properties.externalDescriptor, str, ],
        amount: typing.Union[MetaOapg.properties.amount, decimal.Decimal, int, float, ],
        periodSec: typing.Union[MetaOapg.properties.periodSec, decimal.Decimal, int, float, ],
        action: typing.Union[MetaOapg.properties.action, str, ],
        asset: typing.Union[MetaOapg.properties.asset, str, ],
        type: typing.Union[MetaOapg.properties.type, str, ],
        amountScope: typing.Union[MetaOapg.properties.amountScope, str, ],
        amountCurrency: typing.Union[MetaOapg.properties.amountCurrency, str, ],
        operator: typing.Union[MetaOapg.properties.operator, str, schemas.Unset] = schemas.unset,
        operators: typing.Union[MetaOapg.properties.operators, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        transactionType: typing.Union[MetaOapg.properties.transactionType, str, schemas.Unset] = schemas.unset,
        designatedSigner: typing.Union[MetaOapg.properties.designatedSigner, str, schemas.Unset] = schemas.unset,
        designatedSigners: typing.Union[MetaOapg.properties.designatedSigners, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        srcType: typing.Union[MetaOapg.properties.srcType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        srcSubType: typing.Union[MetaOapg.properties.srcSubType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        srcId: typing.Union[MetaOapg.properties.srcId, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        src: typing.Union[MetaOapg.properties.src, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        dstType: typing.Union[MetaOapg.properties.dstType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        dstSubType: typing.Union[MetaOapg.properties.dstSubType, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        dstId: typing.Union[MetaOapg.properties.dstId, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        dst: typing.Union[MetaOapg.properties.dst, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        dstAddressType: typing.Union[MetaOapg.properties.dstAddressType, str, schemas.Unset] = schemas.unset,
        authorizers: typing.Union[MetaOapg.properties.authorizers, list, tuple, schemas.Unset] = schemas.unset,
        authorizersCount: typing.Union[MetaOapg.properties.authorizersCount, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        authorizationGroups: typing.Union[MetaOapg.properties.authorizationGroups, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        amountAggregation: typing.Union[MetaOapg.properties.amountAggregation, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        rawMessageSigning: typing.Union[MetaOapg.properties.rawMessageSigning, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
        applyForApprove: typing.Union[MetaOapg.properties.applyForApprove, bool, schemas.Unset] = schemas.unset,
        applyForTypedMessage: typing.Union[MetaOapg.properties.applyForTypedMessage, bool, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'PolicyRule':
        return super().__new__(
            cls,
            *_args,
            externalDescriptor=externalDescriptor,
            amount=amount,
            periodSec=periodSec,
            action=action,
            asset=asset,
            type=type,
            amountScope=amountScope,
            amountCurrency=amountCurrency,
            operator=operator,
            operators=operators,
            transactionType=transactionType,
            designatedSigner=designatedSigner,
            designatedSigners=designatedSigners,
            srcType=srcType,
            srcSubType=srcSubType,
            srcId=srcId,
            src=src,
            dstType=dstType,
            dstSubType=dstSubType,
            dstId=dstId,
            dst=dst,
            dstAddressType=dstAddressType,
            authorizers=authorizers,
            authorizersCount=authorizersCount,
            authorizationGroups=authorizationGroups,
            amountAggregation=amountAggregation,
            rawMessageSigning=rawMessageSigning,
            applyForApprove=applyForApprove,
            applyForTypedMessage=applyForTypedMessage,
            _configuration=_configuration,
            **kwargs,
        )

from fireblocks_client.model.amount_aggregation_time_period_method import AmountAggregationTimePeriodMethod
from fireblocks_client.model.policy_src_or_dest_sub_type import PolicySrcOrDestSubType
from fireblocks_client.model.policy_src_or_dest_type import PolicySrcOrDestType
