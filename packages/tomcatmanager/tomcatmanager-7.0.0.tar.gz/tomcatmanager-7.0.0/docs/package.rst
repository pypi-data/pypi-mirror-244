Use from Python
===============


Connect to the server
---------------------

Before you can do anything useful, you need to create a `TomcatManager` object
and connect to a server.

.. automethod:: tomcatmanager.tomcat_manager.TomcatManager.connect
    :noindex:


Responses from the server
-------------------------

All the methods of :class:`.TomcatManager` which interact with the server
return a response in the form of a :class:`.TomcatManagerResponse` object.
Use this object to check whether the command completed successfully, and to
get any results generated by the command.

.. autoclass:: tomcatmanager.models.TomcatManagerResponse
    :members:
    :noindex:


Managing Applications
---------------------

This library provides a robust API to manage applications in a tomcat server.
The following methods are available:

- :meth:`.TomcatManager.list` - return a list of all installed applications
- :meth:`.TomcatManager.deploy_localwar` - deploy a warfile on the local
  filesystem to the Tomcat server
- :meth:`.TomcatManager.deploy_serverwar` - deploy a war file from the server
  filesystem to the Tomcat server
- :meth:`.TomcatManager.deploy_servercontext` - deploy an application defined by a
  context file from the server filesystem to the Tomcat server
- :meth:`.TomcatManager.undeploy` - undeploy an application in the Tomcat server
- :meth:`.TomcatManager.start` - start an application already deployed in the
  Tomcat server
- :meth:`.TomcatManager.stop` - stop an application already deployed in the
  Tomcat server
- :meth:`.TomcatManager.reload` - stop and start a tomcat application
- :meth:`.TomcatManager.sessions` - get the age of the sessions for an application.
- :meth:`.TomcatManager.expire` - expire idle sessions


Parallel Deployment
-------------------

Tomcat supports a `parallel deployment feature
<https://tomcat.apache.org/tomcat-10.0-doc/config/context.html#Parallel_deplo
yment>`_ which allows multiple versions of the same WAR to be deployed
simultaneously at the same URL. To utilize this feature, you need to deploy an
application with a version string. The combination of path and version string
uniquely identify the application::

    >>> tomcat = getfixture("tomcat")
    >>> safe_path = getfixture("safe_path")
    >>> localwar_file = getfixture("localwar_file")
    >>> with open(localwar_file, "rb") as localwar_fileobj:
    ...     r = tomcat.deploy_localwar(safe_path, localwar_fileobj, version="42")
    ...     r.ok
    True
    >>> with open(localwar_file, "rb") as localwar_fileobj:
    ...     r = tomcat.deploy_localwar(safe_path, localwar_fileobj, version="43")
    ...     r.ok
    True

We now have two instances of the same application, deployed at the same
location, but with different version strings. To do anything to either of those
applications, you must supply both the path and the version string::

    >>> r = tomcat.stop(path=safe_path, version="42")
    >>> r.ok
    True
    >>> r = tomcat.undeploy(path=safe_path, version="42")
    >>> r.ok
    True
    >>> r = tomcat.undeploy(path=safe_path, version="43")
    >>> r.ok
    True

The following methods include an optional version parameter to support parallel
deployments:

- :meth:`~.TomcatManager.deploy_localwar`
- :meth:`~.TomcatManager.deploy_serverwar`
- :meth:`~.TomcatManager.deploy_servercontext`
- :meth:`~.TomcatManager.undeploy`
- :meth:`~.TomcatManager.start`
- :meth:`~.TomcatManager.stop`
- :meth:`~.TomcatManager.reload`
- :meth:`~.TomcatManager.sessions`
- :meth:`~.TomcatManager.expire`


Information about Tomcat
------------------------

There are a number of methods which just return information about the Tomcat
server. With the exception of :meth:`.TomcatManager.find_leakers` (which
triggers garbage collection), these methods don't effect any change on the
server.

- :meth:`.TomcatManager.find_leakers` - find applications that are leaking memory
- :meth:`.TomcatManager.resources` - get global JNDI resources
- :meth:`.TomcatManager.server_info` - get information about the tomcat server
- :meth:`.TomcatManager.status_xml` - get server status information in xml format
- :meth:`.TomcatManager.thread_dump` - get a jvm thread dump
- :meth:`.TomcatManager.vm_info` - get diagnostic information about the jvm


SSL/TLS
-------

Tomcat servers can be configured to serve their applications over SSL/TLS.
This library includes a few related methods:

- :meth:`.TomcatManager.ssl_connector_ciphers` - get SSL/TLS ciphers for eac
  connector
- :meth:`.TomcatManager.ssl_connector_certs` - get the certificate chain for
  each virtual host
- :meth:`.TomcatManager.ssl_connector_trusted_certs` - get the trusted certificates
  for each virtual host
- :meth:`.TomcatManager.ssl_reload` - reload certificates and keys

The :meth:`.TomcatManager.ssl_reload` is the only one of these methods that
causes the server to take any action, the rest are informational only.


Differences in Tomcat Versions
------------------------------

As Tomcat matured, it added new capabilities. For example, Tomcat 8.5 added
a new command ``ssl_reload``. This library added support for that command
in version 2.0.0. However, if the server you were connected to happened to
be running Tomcat 8.0, a somewhat rather generic exception was thrown.

In version 3.0.0, this library was enhanced so it understood all the supported
versions of Tomcat (see :class:`~.models.TomcatMajorMinor`), and which versions of
Tomcat supported each of the available API calls.

If you call a method that is not implemented by the particular server you are
connected to, :exc:`~.models.TomcatNotImplementedError` will be raised.

.. note::

  In version 6.0.0 of this library and higher, all python API methods are available in
  all supported Tomcat versions. Therefore, this version of the library will not raise
  :exc:`~.models.TomcatNotImplementedError` exceptions.

  However, you should still check for these exceptions in your code, and if you are
  already checking for them, you definitely shouldn't delete those checks. This
  exception, and the related :meth:`.TomcatManager.implements` and
  :meth:`.TomcatManager.implemented_by` methods are not deprecated in case they are
  needed in future versions.

If you prefer to check whether a method is supported before calling it, you
can do so using :meth:`.TomcatManager.implements`:

    >>> tomcat = getfixture("tomcat")
    >>> if tomcat.implements(tomcat.list):
    ...     print("list is implemented")
    ... else:
    ...     print("list is not implemented")
    list is implemented

If you call :meth:`.TomcatManager.implements` and are not connected to a
server, :exc:`~.models.TomcatNotConnected` will be raised.

There is a way to check whether a method is supported without connecting
to a server. You must specify the version of the Tomcat server and the
method you want to check is implemented. Use one of the values in the enumeration
:class:`~.models.TomcatMajorMinor` to specify the version of Tomcat you
want to check::

    >>> import tomcatmanager as tm
    >>> tomcat = tm.TomcatManager()
    >>> tver = tm.TomcatMajorMinor.V8_5
    >>> print(tomcat.implemented_by(tomcat.ssl_reload, tver))
    True


Specifying As A Dependency
--------------------------

If you incorporate ``tomcatmanager`` into your own package, you will need to specify
it as a dependency. I strongly recommend you specify the dependency such that it
limits usage to a single major version of this library. This way when a new major
version of this library is released, it won't break your code. You should specify your
``pyproject.toml`` dependency like this::

    [project]
    dependencies = [
        "tomcatmanager>=5,<6"
    ]


When this library adds support for a new version of Tomcat or Python, we increment the
minor version number. However, if support for these new versions requires API changes
incompatible with prior releases of this software, then we increment the major version
number.

When this library drops support for a version of Tomcat or Python, we increment the
major version number. For example, when this project dropped support for Python 3.6,
we released that version as 5.0.0 instead of 4.1.0, even though there were no
incompatible API changes.

These versioning rules were chosen so that if you are using this library against a
single version of Tomcat, and you specify your dependency rules as suggested above,
you will not have to worry about a future release of this software breaking your
setup.

For example, say you are using Tomcat 8.0, which is supported by version 5.x of this
library. You should specify your ``pyproject.toml`` dependency rules::

    [project]
    dependencies = [
        "tomcatmanager>=5,<6"
    ]

When version 6.x of this library was released it dropped support for Tomcat 8.0.
Without this dependency rule, ``pip`` would upgrade to the new version of this
library, which would break your application which needs to talk to a Tomcat 8.0
server.

Once you have migrated your server infrastructure to a newer version of Tomcat, you
can change your dependency rules::

    [project]
    dependencies = [
        "tomcatmanager>=6,<7"
    ]
