# Copyright 2023 Marc Lehmann

# This file is part of tablecache.
#
# tablecache is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# tablecache is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License
# along with tablecache. If not, see <https://www.gnu.org/licenses/>.

import asyncio

import asyncpg
from hamcrest import *
import pytest

import tablecache as tc


@pytest.fixture(scope='session')
def postgres_host():
    import socket
    try:
        return socket.gethostbyname('postgres')
    except socket.gaierror:
        return 'localhost'


@pytest.fixture(scope='session')
def postgres_dsn(postgres_host):
    return f'postgres://postgres:@{postgres_host}:5432/postgres'


@pytest.fixture(scope='session')
async def wait_for_postgres(postgres_dsn):
    start_time = asyncio.get_running_loop().time()
    while True:
        try:
            conn = await asyncpg.connect(dsn=postgres_dsn)
            await conn.close()
            return
        except Exception as e:
            if asyncio.get_running_loop().time() > start_time + 60:
                raise Exception('Testing Postgres isn\'t coming up.') from e
            await asyncio.sleep(0.1)


@pytest.fixture(scope='session')
async def pool(wait_for_postgres, postgres_dsn):
    async with asyncpg.create_pool(dsn=postgres_dsn) as pool:
        yield pool


@pytest.fixture(autouse=True)
async def setup_db(pool):
    await pool.execute(
        '''
        DROP SCHEMA public CASCADE;
        CREATE SCHEMA public;
        CREATE TABLE users (
            user_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            name text NOT NULL,
            age integer
        );
        CREATE TABLE cities (
            city_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
            name text NOT NULL
        );
        CREATE TABLE users_cities (
            user_id integer PRIMARY KEY REFERENCES users(user_id),
            city_id integer NOT NULL REFERENCES cities(city_id)
        );''')


@pytest.fixture
def insert_user(pool):
    async def inserter(user_id, user_name, user_age, city_id, city_name):
        await pool.execute(
            '''INSERT INTO users (user_id, name, age)
            VALUES ($1, $2, $3) ON CONFLICT (user_id) DO NOTHING''', user_id,
            user_name, user_age)
        await pool.execute(
            '''INSERT INTO cities (city_id, name)
            VALUES ($1, $2) ON CONFLICT (city_id) DO NOTHING''', city_id,
            city_name)
        await pool.execute(
            '''INSERT INTO users_cities (user_id, city_id)
            VALUES ($1, $2) ON CONFLICT (user_id) DO NOTHING''', user_id,
            city_id)

    return inserter


async def collect_async_iter(i):
    l = []
    async for item in i:
        l.append(item)
    return l


class TestPostgresTable:
    @pytest.fixture
    def make_table(self, pool):
        def factory(query_subset_string=None, query_pks_string=None):
            query_subset_string = query_subset_string or '''
                SELECT
                    uc.*, u.name AS user_name, u.age AS user_age,
                    c.name AS city_name
                FROM
                    users u
                    JOIN users_cities uc USING (user_id)
                    JOIN cities c USING (city_id)'''
            query_pks_string = (
                query_pks_string
                or f'{query_subset_string} WHERE uc.user_id = ANY ($1)')
            return tc.PostgresTable(
                pool, query_subset_string, query_pks_string)

        return factory

    @pytest.fixture
    def table(self, make_table):
        return make_table()

    async def test_get_record_subset_on_empty(self, table):
        assert_that(
            await collect_async_iter(
                table.get_record_subset(tc.All.with_primary_key('user_id')())),
            empty())

    async def test_get_record_subset_on_one(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        assert_that(
            await collect_async_iter(
                table.get_record_subset(tc.All.with_primary_key('user_id')())),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_age=1, city_id=11,
                    city_name='c1')))

    async def test_get_record_subset_on_many(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        await insert_user(2, 'u2', None, 11, 'c1')
        await insert_user(3, 'u3', 3, 12, 'c2')
        assert_that(
            await collect_async_iter(
                table.get_record_subset(tc.All.with_primary_key('user_id')())),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_age=1, city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=2, user_name='u2', user_age=None, city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=3, user_name='u3', user_age=3, city_id=12,
                    city_name='c2')))

    async def test_get_records_on_empty(self, table):
        assert_that(await collect_async_iter(table.get_records([])), empty())

    async def test_get_records_on_none(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        assert_that(await collect_async_iter(table.get_records([])), empty())

    async def test_get_records_on_none_matching(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        assert_that(
            await collect_async_iter(table.get_records([2, 3])), empty())

    async def test_get_records_on_one(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        assert_that(
            await collect_async_iter(table.get_records([1])),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_age=1, city_id=11,
                    city_name='c1')))

    async def test_get_records_on_many(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        await insert_user(2, 'u2', None, 11, 'c1')
        await insert_user(3, 'u3', 3, 12, 'c2')
        assert_that(
            await collect_async_iter(table.get_records([1, 2, 3, 4])),
            contains_inanyorder(
                has_entries(
                    user_id=1, user_name='u1', user_age=1, city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=2, user_name='u2', user_age=None, city_id=11,
                    city_name='c1'),
                has_entries(
                    user_id=3, user_name='u3', user_age=3, city_id=12,
                    city_name='c2')))

    async def test_get_record_raises_on_nonexistent(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        with pytest.raises(KeyError):
            await table.get_record(2)

    async def test_get_record(self, table, insert_user):
        await insert_user(1, 'u1', 1, 11, 'c1')
        assert_that(
            await table.get_record(1),
            has_entries(
                user_id=1, user_name='u1', user_age=1, city_id=11,
                city_name='c1'))

    async def test_get_record_subset_with_custom_subset(
            self, make_table, insert_user):
        class AgeRangeSubset(tc.Subset):
            def __init__(self, age_ge, age_lt):
                self.age_ge = age_ge
                self.age_lt = age_lt

            @property
            def score_intervals(self):
                return [tc.Interval(self.age_ge, self.age_lt)]

            @property
            def db_args(self):
                return (self.age_ge, self.age_lt)

        table = make_table(
            'SELECT * FROM users WHERE age >= $1 AND age < $2',
            'SELECT * FROM users WHERE user_id = ANY($1)')
        for i in range(1, 6):
            await insert_user(i, f'u{i}', i, 11, 'c1')
        await insert_user(6, 'u6', None, 11, 'c1')
        assert_that(
            await collect_async_iter(
                table.get_record_subset(AgeRangeSubset(-1, 10))),
            contains_inanyorder(
                *[has_entries(user_id=i, age=i) for i in range(1, 6)],))
        assert_that(
            await
            collect_async_iter(table.get_record_subset(AgeRangeSubset(2, 4))),
            contains_inanyorder(
                *[has_entries(user_id=i, age=i) for i in range(2, 4)],))
