# Copyright (C) 2023 liancea
#
# This file is part of ffmpeg-auto-settings.
#
# ffmpeg-auto-settings is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License Version 3 as published by the Free Software Foundation.
#
# ffmpeg-auto-settings is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
# the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with ffmpeg-auto-settings. If not, see
# <https://www.gnu.org/licenses/>.

import sys
import os
import re
from importlib import resources
from pathlib import Path
import subprocess
from datetime import timedelta
from typing import Type, TypeVar
from functools import wraps, cache
from . import files

FFAS_PATH = Path('.ffas')
ORDERED_PRESETS = [
    'ultrafast', 'superfast', 'veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow', 'placebo'
]


def print_err(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)


T = TypeVar('T')


def singleton(cls: Type[T]):
    # from https://peps.python.org/pep-0318/#examples
    instances = {}

    @wraps(cls)
    def getinstance() -> T:
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance


class FFmpegTimedelta(timedelta):
    """
    ffmpeg-compatible timedelta

    Works like datetime.timedelta, except you can create instances from ffmpeg time strings and its string format
    (`str(instance)`) is a human-readable ffmpeg time string again.
    """

    @classmethod
    def from_ffmpeg_time(cls: Type[T], time_string: str) -> T:
        """
        Create an instance from an ffmpeg time string

        The following time string formats are supported:
        1) [<[[[H]H]H]H>:]<[M]M>:<[S]S>[.<m>...]
        2) <S>+[.<m>...][s]

        Time strings with "ms" or "us" suffixes are not supported.

        Examples:
         - 1:30:44
         - 1:30:44.82764
         - 5444.82764
        :param time_string: ffmpeg time string
        """
        long_form = re.fullmatch(
            r'((?P<hours>[0-9]{1,4}):)?(?P<minutes>[0-5]?[0-9]):(?P<seconds>[0-5]?[0-9](\.[0-9]+)?)',
            time_string
        )
        if long_form:
            matches = long_form.groupdict()
            hours = int(matches['hours'] or 0)
            minutes = int(matches['minutes'])
            seconds = float(matches['seconds'])
            return cls(hours=hours, minutes=minutes, seconds=seconds)

        short_form = re.fullmatch(r'(?P<seconds>[0-9]+(.[0-9]+)?)s?', time_string)
        if short_form:
            seconds = float(short_form.group('seconds'))
            return cls(seconds=seconds)

        # if we land here, neither the long_form nor the short_form matched
        raise ValueError("Invalid time_string - must look similar to ffmpeg's time durations")

    def __str__(self):
        # convert to int to preserve precise value (after-comma fraction is dealt with later)
        full_seconds = int(self.total_seconds())
        hours = full_seconds // 3600
        full_seconds %= 3600
        minutes = full_seconds // 60
        full_seconds %= 60

        seconds_fraction = f'{self.total_seconds():.6f}'.split('.')[1].rstrip('0')
        time_string = f'{hours:02}:{minutes:02}:{full_seconds:02}{f".{seconds_fraction}" if seconds_fraction else ""}'

        return time_string


def generate_new_uid() -> str:
    """
    Generate new locally unique ID

    generated by stuffing 5 random bytes into an integer, represented as hex string without leading 0x but with
    leading zeroes to fill up to 10 characters
    :return: id (str)
    """
    rand_int = int.from_bytes(os.urandom(5), 'big')
    hex_str = hex(rand_int)[2:]
    return f'{hex_str:0>10}'


def run_ffmpeg_command(cmd_line):
    try:
        subprocess.run(cmd_line, check=True, stdout=sys.stdout, stderr=sys.stderr)
    except FileNotFoundError:
        print_err('Error: ffmpeg not found')
        sys.exit(1)
    except subprocess.CalledProcessError:
        cmd_line_formatted = " ".join([f"'{arg}'" for arg in cmd_line])
        print_err(f'Error: ffmpeg returned an error. command line: {cmd_line_formatted}')
        sys.exit(1)


def get_video_duration(filename) -> FFmpegTimedelta:
    try:
        command = (
            'ffprobe',
            '-loglevel', 'quiet',
            '-print_format', 'compact=print_section=0:nokey=1:escape=csv',
            '-show_entries', 'format=duration',
            filename
        )
        proc = subprocess.run(command, capture_output=True, check=True, text=True)
        return FFmpegTimedelta.from_ffmpeg_time(proc.stdout.strip())
    except FileNotFoundError:
        print_err('Error: ffprobe not found')
        sys.exit(1)


def get_video_stream_bitrate(filename) -> int:
    try:
        command = (
            'ffprobe',
            '-loglevel', 'quiet',
            '-print_format', 'compact=print_section=0:nokey=1:escape=csv',
            '-select_streams', 'v:0',
            '-show_entries', 'stream=bit_rate',
            filename
        )
        proc = subprocess.run(command, capture_output=True, check=True, text=True)
        return int(proc.stdout.strip())
    except FileNotFoundError:
        print_err('Error: ffprobe not found')
        sys.exit(1)


def ensure_acceptable_ffmpeg() -> None:
    # check if ffmpeg can be found and was compiled with libvmaf support
    try:
        proc = subprocess.run(('ffmpeg', '-version'), capture_output=True, text=True)
    except FileNotFoundError:
        print_err(f'Error: ffmpeg not found!')
        sys.exit(1)

    if '--enable-libvmaf' not in proc.stdout:
        print_err('Error: your ffmpeg installation has no support for libvmaf!')

    # check if ffprobe can be found
    try:
        subprocess.run('ffprobe', capture_output=True)
    except FileNotFoundError:
        print_err(f'Error: ffprobe not found!')
        sys.exit(1)


def get_extension_for_mimetype(mimetype: str) -> str:
    try:
        return get_internal_mimetype_extension_mapping()[mimetype]
    except KeyError:
        return get_system_mimetype_extension_mapping()[mimetype]


@cache
def get_system_mimetype_extension_mapping():
    # use system's mime.types if possible, bundled one otherwise
    system_mimetype_path = Path('/etc/mime.types')
    if system_mimetype_path.is_file():
        f = system_mimetype_path.open('r')
    else:
        f = resources.files(files).joinpath('mime.types').open('r')
    try:
        extensions = {}
        for line in f:
            if line.startswith('#'):
                continue
            splits = line.split()
            if len(splits) <= 1:
                # mimetype without extension
                continue
            # note first mentioned extension, ignore the others
            extensions[splits[0]] = splits[1]
    finally:
        f.close()
    return extensions


def get_internal_mimetype_extension_mapping():
    # provide a few well-known extensions, because
    # 1) at least Ubuntu 22.04 thinks .mpv is a nice extension for matroska, which
    #    doesn't seem to be usually associated with video players in Windows
    # 2) it's nice to be able to provide most video extensions, but also overkill
    #    to parse /etc/mime.types every time
    return {
        'video/mp4': 'mp4',
        'video/x-matroska': 'mkv'
    }
