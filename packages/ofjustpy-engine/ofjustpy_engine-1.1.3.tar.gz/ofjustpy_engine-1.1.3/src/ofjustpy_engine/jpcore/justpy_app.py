"""
Created on 2022-09-02

@author: wf
"""
import asyncio
import fnmatch
import inspect
import json
import logging
import os
import pathlib
import socket
import sys
import traceback
import typing
import uuid
from sys import platform
from threading import Thread

from . import jpconfig
import uvicorn
from itsdangerous import Signer
from . import AppDB
from .justpy_config import JpConfig
from .template import Context
from ..WebPage_type_mixin import WebPageType
from py_tailwind_utils import dget
from starlette.applications import Starlette
from starlette.authentication import requires as auth_requires
from starlette.endpoints import HTTPEndpoint
from starlette.responses import HTMLResponse
from starlette.responses import JSONResponse
from starlette.responses import PlainTextResponse
from starlette.responses import Response
from starlette.routing import Mount
from starlette.routing import Route
from starlette.templating import Jinja2Templates

# import psutil

# TODO refactor to object oriented version where this is a property of some instance of some class
cookie_signer = Signer(str(jpconfig.SECRET_KEY))


def create_component_file_list():
    """
    create the component file list
    """
    file_list = []
    component_dir = os.path.join(jpconfig.STATIC_DIRECTORY, "components")
    if os.path.isdir(component_dir):
        for file in os.listdir(component_dir):
            if fnmatch.fnmatch(file, "*.js"):
                file_list.append(f"/components/{file}")
    return file_list


component_file_list = create_component_file_list()
grand_parent = pathlib.Path(__file__).parent.parent.resolve()
template_dir = f"{grand_parent}/templates"
lib_dir = os.path.join(template_dir, "js", jpconfig.FRONTEND_ENGINE_TYPE)
# remove .js extension
jpconfig.FRONTEND_ENGINE_LIBS = [
    fn[:-3] for fn in os.listdir(lib_dir) if fnmatch.fnmatch(fn, "*.js")
]
TEMPLATES_DIRECTORY = JpConfig.config(
    "TEMPLATES_DIRECTORY", cast=str, default=template_dir
)

templates = Jinja2Templates(directory=TEMPLATES_DIRECTORY)

template_options = {
    "static_name": jpconfig.STATIC_NAME,
    "component_file_list": component_file_list,
    "no_internet": jpconfig.NO_INTERNET,
    "base_url": jpconfig.BASE_URL,
}
from addict_tracking_changes import Dict


def target_of(item, stubStore):
    """
    item is a stub or staticCore
    supports item.id which is spath
    for the item
    """
    return dget(stubStore, item.id).target


async def run_event_function(
    dbref, event_type, event_data, create_namespace_flag=True, stubStore=None
):
    """
    dbref: the hc-object on which event is called
    """
    event_function = dbref.get_event_handler(event_type)

    if create_namespace_flag:
        function_data = Dict(event_data)
    else:
        function_data = event_data

    if inspect.iscoroutinefunction(event_function):
        event_result = await event_function(
            dbref, function_data, lambda x, stubStore=stubStore: target_of(x, stubStore)
        )

    else:
        try:
            event_result = event_function(
                dbref,
                function_data,
                lambda x, stubStore=stubStore: target_of(x, stubStore),
            )
        except Exception as e:
            print(
                "=========================================================> Error in event handling =============================================================="
            )
            print("unable to call ", e)
            raise e
    return event_result


async def handle_event(data_dict, com_type=0, page_event=False):
    """
    handle the given event

    Args:
        data_dict(dict): the dict with the data
        com_type(int):  the communication type - default: 0
        page_event(bool): if True handle as a page event
    """
    # com_type 0: websocket, con_type 1: ajax
    connection_type = {0: "websocket", 1: "ajax"}
    event_data = data_dict["event_data"]
    try:
        p = AppDB.pageId_to_webpageInstance[event_data["page_id"]]
    except:
        logging.warning("No page to load")
        return
    event_data["page"] = p
    if com_type == 0:
        event_data["websocket"] = AppDB.pageId_to_websockets[event_data["page_id"]][
            event_data["websocket_id"]
        ]
    # The page_update event is generated by the reload_interval Ajax call
    if event_data["event_type"] == "page_update":
        build_list = p.build_list()
        return {"type": "page_update", "data": build_list}

    if page_event:
        c = p
    else:
        component_id = event_data["id"]
        c = dget(p.session_manager.stubStore, component_id).target

        if c is not None:
            event_data["target"] = c
        else:
            logging.warning(
                f"component with id {component_id} doesn't exist (anymore ...) it might have been deleted before the event handling was triggered"
            )

    # Turning of before_<event_type> and after_<event_type> until proper use case is found
    # Also, need to move this to mixin -- so that it can used per component-type  basis
    # try:
    #     if c is not None:
    #         before_result = await c.run_event_function("before", event_data, True)
    # except:
    #     pass
    try:
        if c is not None:
            if True:
                event_result = await run_event_function(
                    c,
                    event_data["event_type"],
                    event_data,
                    True,
                    stubStore=p.session_manager.stubStore,
                )

            else:
                event_result = None
                logging.debug(f"{c} has no {event_data['event_type']} event handler")
        else:
            event_result = None
    except Exception as e:
        if jpconfig.CRASH:
            print(traceback.format_exc())
        event_result = None
        logging.info("%s", traceback.format_exc())
        print(traceback.format_exc())
        print("Event handling failed ", e)
        raise e

    # If page is not to be updated, the event_function should return anything but None
    if event_result is None:
        if com_type == 0:  # WebSockets communication
            if jpconfig.LATENCY:
                await asyncio.sleep(jpconfig.LATENCY / 1000)

            await p.update()
            # flush cookies if cookies are being used and
            # flag has been raised

            if p.flush_cookies_flag:
                await p.flush_cookies()

        elif com_type == 1:  # Ajax communication
            build_list = p.build_list()

    # before_<event_type> and after_<event_type> is turned off for normal operation
    # unless new use cases are found.
    # try:
    #     if c is not None:
    #         after_result = await c.run_event_function("after", event_data, True)
    # except:
    #     pass
    if com_type == 1 and event_result is None:
        dict_to_send = {
            "type": "page_update",
            "data": build_list,
            "page_options": {
                "display_url": p.display_url,
                "title": p.title,
                "redirect": p.redirect,
                "open": p.open,
                "favicon": p.favicon,
            },
        }
        return dict_to_send


# https://stackoverflow.com/questions/57412825/how-to-start-a-uvicorn-fastapi-in-background-when-testing-with-pytest
# https://github.com/encode/uvicorn/discussions/1103
# https://stackoverflow.com/questions/68603658/how-to-terminate-a-uvicorn-fastapi-application-cleanly-with-workers-2-when
class JustpyApp(Starlette):
    """
    a justpy application is a special Starlette application

      uses starlette Routing

    see
       https://www.starlette.io/routing/

       https://github.com/encode/starlette/blob/master/starlette/routing.py
    """

    # @Todo - legacy for SetRoute
    app = None

    def __init__(self, **kwargs):
        # https://www.starlette.io/applications/
        self.cookie_state_attr_names = kwargs.get("cookie_state_attr_names", [])
        kwargs.pop("cookie_state_attr_names")
        Starlette.__init__(self, **kwargs)
        # @Todo - legacy for SetRoute
        JustpyApp.app = self

    def route_as_text(self, route):
        """
        get a string representation of the given route
        """
        text = f"{route.__class__.__name__}(name: {route.name}, path: {route.path}, format: {route.path_format},  regex: {route.path_regex})"
        if isinstance(route, Route):
            text += f"func: {route.endpoint.__name__}"
        return text

    def add_jproute(self, path: str, wpfunc: typing.Callable, name: str = None):
        """
        add a route for the given Webpage returning func

        Args:
            path(str): the path to use as route
            wpfunc(typing.Callable): a Webpage returning func
            name(str): the name of the route
        """
        endpoint = self.response(wpfunc)

        if name is None:
            name = wpfunc.__name__
        self.router.add_route(path, endpoint, name=name, include_in_schema=False)

    def mount_routes(self, mount_point, jproutes):
        """
        app.mount has bugs potentially due to template rendering (which needs to go away).
        this is a workaround to mount a bunch of endpoints under a common endpoint.
        """

        routes = [
            Route(path, self.response(func), name=name) for path, func, name in jproutes
        ]
        self.router.routes.append(Mount(mount_point, routes=routes))

    def requires(self, scopes, status_code=403, redirect=None):
        auth_decorator = auth_requires(scopes, status_code, redirect)

        def wrapper(func):
            return auth_decorator(func)

        return wrapper

    def add_route(
        self, path: str, name: typing.Optional[str] = None, methods=["GET", "POST"]
    ) -> typing.Callable:  # pragma: nocover
        """
        justpy route decorator

        function will we "wrapped" as a response and a route added

        Args:
            func(typing.Callable): the function to convert to a reponse
        """

        def routeResponse(func: typing.Callable) -> typing.Callable:
            """
            decorator for the given func

            Args:
                func(typing.Callable)

            Returns:
                Callable: an endpoint that has been routed

            """
            endpoint = self.response(func)
            self.router.add_route(
                path,
                endpoint,
                name=name if name is not None else func.__name__,
                methods=methods,
                include_in_schema=False,
            )
            self.route(path)
            return endpoint

        return routeResponse

    def response(self, func: typing.Callable):
        """
        response decorator converts a function to a response

        see also https://github.com/justpy-org/justpy/issues/532
        castAsEndPoint

        Args:
            func(typing.Callable): the function (returning a WebPage) to convert to a response
        """

        async def funcResponse(request) -> HTMLResponse:
            """
            decorator function to apply the function to the request and
            return it as a response

            Args:
                request(Request): the request to apply the function to

            Returns:
                Response: a HTMLResponse applying the justpy infrastructure

            """
            new_cookie = self.handle_session_cookie(request)
            
            wp = await self.get_page_for_func(request, func)
            response = wp.get_response_for_load_page(request)
            response = self.set_cookie(request, response, wp, new_cookie)
            if jpconfig.LATENCY:
                await asyncio.sleep(jpconfig.LATENCY / 1000)
            return response

        # return the decorated function, thus allowing access to the func
        # parameter in the funcResponse later when applied
        return funcResponse

    async def get_page_for_func(self, request, func: typing.Callable):
        """
        get the Webpage for the given func

        Args:
            request: the request to pass to the given function
            func: the function

        Returns:
            WebPage: the Webpage returned by the given function
        """
        # @TODO - get rid of the global func_to_run concept that isn't
        # in scope here (anymore) anyways

        func_to_run = func
        func_parameters = len(inspect.signature(func_to_run).parameters)
        if inspect.iscoroutinefunction(func_to_run):
            if func_parameters > 0:
                load_page = await func_to_run(request, **request.path_params)
            else:
                load_page = await func_to_run()
        else:
            if func_parameters > 0:
                load_page = func_to_run(request, **request.path_params)
            else:
                load_page = func_to_run()
        return load_page

    # def get_response_for_load_page(self, request, load_page):
    #     """
    #     get the response for the given webpage

    #     Args:
    #         request(Request): the request to handle
    #         load_page(WebPage): the webpage to wrap with justpy and
    #         return as a full HtmlResponse

    #     Returns:
    #         Reponse: the response for the given load_page
    #     """
    #     page_options = {
    #         "reload_interval": load_page.reload_interval,
    #         "body_style": load_page.body_style,
    #         "body_classes": load_page.classes,
    #         "css": load_page.css,
    #         "head_html": load_page.head_html,
    #         "body_html": load_page.body_html,
    #         "display_url": load_page.display_url,
    #         # "dark": load_page.dark,
    #         "title": load_page.title,
    #         "redirect": load_page.redirect,
    #         "debug": load_page.debug,
    #         "events": load_page.events,
    #         "favicon": load_page.favicon if load_page.favicon else jpconfig.FAVICON,
    #     }

    #     if load_page.use_cache:
    #         page_dict = load_page.cache
    #     else:
    #         if hasattr(load_page, "to_json_optimized"):
    #             page_json = load_page.build_json()
    #             pass
    #         else:
    #             page_dict = load_page.build_list()
    #             page_json = json.dumps(page_dict, default=str)

    #     context = {
    #         "request": request,
    #         "page_id": load_page.page_id,
    #         "justpy_dict": page_json,
    #         "use_websockets": json.dumps(
    #             load_page.use_websockets
    #         ),  # json.dumps(WebPage.use_websockets),
    #         "options": template_options,
    #         "page_options": page_options,
    #         "html": load_page.html,
    #         "frontend_engine_type": jpconfig.FRONTEND_ENGINE_TYPE,
    #         "frontend_engine_libs": jpconfig.FRONTEND_ENGINE_LIBS,
    #     }
    #     # wrap the context in a context object to make it available

    #     if not load_page.use_websockets:
    #         logging.info("websocket turned off for this page")
    #     context_obj = Context(context)
    #     context["context_obj"] = context_obj
    #     response = templates.TemplateResponse(load_page.template_file, context)

    #     return response

    def handle_session_cookie(self, request) -> typing.Union[bool, Response]:
        """
        handle the session cookie for this request

        Returns:
            True if a new cookie and session has been created
        """
        # Handle web requests
        session_cookie = request.cookies.get(jpconfig.SESSION_COOKIE_NAME)
        new_cookie = None
        if jpconfig.SESSIONS:
            new_cookie = False
            if session_cookie:
                try:
                    session_id = cookie_signer.unsign(session_cookie).decode("utf-8")
                except:
                    return PlainTextResponse("Bad Session")
                request.state.session_id = session_id
                request.session_id = session_id
            else:
                # Create new session_id
                request.state.session_id = str(uuid.uuid4().hex)
                request.session_id = request.state.session_id
                new_cookie = True
                logging.debug(f"New session_id created: {request.session_id}")
        return new_cookie

    def set_cookie(
        self, request, response, load_page, new_cookie: typing.Union[bool, Response]
    ):
        """
        set the cookie_value

        Args:
            request: the request
            response: the response to be sent
            load_page(WebPage): the WebPage to handle
            new_cookie(bool|Response): True if there is a new cookie. Or Response if cookie was invalid
        """
        if isinstance(new_cookie, Response):
            #print("returning without cookie setting")
            return new_cookie

        if jpconfig.SESSIONS and new_cookie:
            cookie_value = cookie_signer.sign(request.state.session_id)
            cookie_value = cookie_value.decode("utf-8")
            response.set_cookie(
                jpconfig.SESSION_COOKIE_NAME,
                cookie_value,
                max_age=jpconfig.COOKIE_MAX_AGE,
                httponly=True,
            )
            logging.debug(
                f"set signed cookie name={jpconfig.SESSION_COOKIE_NAME} in response object"
            )

        return response


class JustpyAjaxEndpoint(HTTPEndpoint):
    """
    Justpy specific HTTPEndpoint/app (ASGI application)
    """

    def __init__(self, scope, receive, send):
        """
        constructor
        """
        HTTPEndpoint.__init__(self, scope, receive, send)

    async def post(self, request):
        """
        Handles post method. Used in Ajax mode for events when websockets disabled

        Args:
            request(Request): the request to handle
        """
        data_dict = await request.json()
        form = await request.form()

        # {'type': 'event', 'event_data': {'event_type': 'beforeunload', 'page_id': 0}}
        if data_dict["event_data"]["event_type"] == "beforeunload":
            return await self.on_disconnect(data_dict["event_data"]["page_id"])

        session_cookie = request.cookies.get(jpconfig.SESSION_COOKIE_NAME)
        if jpconfig.SESSIONS and session_cookie:
            session_id = cookie_signer.unsign(session_cookie).decode("utf-8")
            data_dict["event_data"]["session_id"] = session_id

        # data_dict['event_data']['session'] = request.session
        msg_type = data_dict["type"]
        data_dict["event_data"]["msg_type"] = msg_type
        page_event = True if msg_type == "page_event" else False
        result = await handle_event(data_dict, com_type=1, page_event=page_event)
        if result:
            if jpconfig.LATENCY:
                await asyncio.sleep(jpconfig.LATENCY / 1000)
            return JSONResponse(result)
        else:
            return JSONResponse(False)

    async def on_disconnect(self, page_id):
        print(f"=============> The StarAppAjaxEndpoint has recieved disconnect")

        await AppDB.pageId_to_webpageInstance[
            page_id
        ].on_disconnect()  # Run the specific page disconnect function
        return JSONResponse(False)


def getDefaultHost():
    host = socket.getfqdn()
    # work around https://github.com/python/cpython/issues/79345
    if (
        host
        == "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa"
    ):
        host = "localhost"
        # host="127.0.0.1"
        return host


def uvicorn_server_control_center(
    host, port, app, sleep_time=0.5, mode="direct", debug=False
):
    def X():
        X.uv_server = None
        X.proc = None
        X.thread = None

        def init():
            """ """
            # TODO: add https server use SSL cert and key
            uvicorn_config = uvicorn.config.Config(
                app, host=host, port=port, log_level=jpconfig.UVICORN_LOGGING_LEVEL
            )

            uv_server = uvicorn.Server(uvicorn_config)
            # jp_server.run()
            return uv_server

        async def start(mode="direct"):
            """ """
            if mode == "direct":
                await asyncio.sleep(sleep_time)  # time for the server to start
                X.thread = Thread(target=X.uv_server.run)
                X.thread.start()
                print("thread has been launched: for uvicorn server")
            elif mode == "process":
                # process mode not supported
                assert False
                pass
            await asyncio.sleep(sleep_time)  # time for the server to start

        async def stop():
            """
            stop the server
            """
            print("uv webserver should stop now")
            if X.uv_server:
                X.uv_server.should_exit = True
                X.uv_server.force_exit = True
                await asyncio.sleep(sleep_time)
                await X.uv_server.shutdown()
            if X.thread:
                X.thread.join(timeout=sleep_time)
            if X.proc:
                # pid = self.proc.pid
                # parent = psutil.Process(pid)
                # for child in parent.children(recursive=True):
                #    child.terminate()
                # self.proc.terminate()
                assert False
                pass
            pass

        def get_url(path):
            """
            get the url for the given path
            """
            url = f"http://{host}:{port}{path}"
            return url

        X.init = init
        X.start = start
        X.stop = stop
        X.get_url = get_url
        pass

    X()
    X.uv_server = X.init()
    return X
