from typing import List, Dict, Generator

import click
from git import Repo
from unidiff import PatchSet
from unidiff.patch import Line

from patched_cli.client.github import GithubClient
from patched_cli.client.patched import PatchedClient
from patched_cli.models.common import Patch, PatchMessage


def get_slug_from_remote_url(remote_url: str):
    # TODO: consider using https://github.com/nephila/giturlparse instead
    if remote_url.startswith("git@"):
        # ssh
        _, _, potential_slug = remote_url.partition(":")
    else:
        potential_slug = "/".join(remote_url.split("/")[-2:])

    return potential_slug.removesuffix(".git")


def create_branch_and_pr(path: str, repo: Repo, applied_patches: List[Patch], is_create_pr: bool,
                         gh_client: GithubClient | None, patched_client: PatchedClient | None) -> str:
    branch = repo.active_branch
    original_branch_name = branch.name
    next_branch_name = f"patched-{original_branch_name}"
    # create branch forcefully, assume we have control
    click.echo(f"Creating new branch \"{next_branch_name}\".")
    next_branch = repo.create_head(next_branch_name, force=True)
    try:
        next_branch.checkout()

        # git add
        for applied_patch in applied_patches:
            repo.git.add(applied_patch.path)

        repo.git.commit("--author", "patched.codes[bot]<298395+patched.codes[bot]@users.noreply.github.com>", "-m",
                        "Patched!")

        if not is_create_pr or (gh_client is None and patched_client is None):
            return f"Branch created at: \"{next_branch.name}\""

        tracking_branch = branch.tracking_branch()
        if tracking_branch is None:
            return ("Unable to create pull request as base branch does not track a remote branch. \n"
                    f"Branch created at: \"{next_branch.name}\"")

        original_remote_name = tracking_branch.remote_name
        original_remote_url = repo.remotes[original_remote_name].url

        click.echo(f"Creating pull request for branch \"{next_branch.name}\" to merge into \"{original_branch_name}\".")
        # force push, assume we have control
        repo.git.push("-f", "--set-upstream", original_remote_name, next_branch.name)

        repo_slug = get_slug_from_remote_url(original_remote_url)
        diff_text = repo.git.diff(original_branch_name)
        if patched_client is not None:
            url = patched_client.create_pr(repo_slug,
                                           path,
                                           diff_text,
                                           original_branch_name,
                                           next_branch_name,
                                           applied_patches)
        if gh_client is not None:
            url = create_pr(repo_slug,
                            path,
                            diff_text,
                            original_branch_name,
                            next_branch_name,
                            applied_patches,
                            gh_client)

        return f"Pull request generated at: \"{url}\""
    finally:
        branch.checkout()


def create_pr(repo_slug: str, path: str, diff_text: str, original_branch_name: str, next_branch_name: str,
              applied_patches: List[Patch], gh_client: GithubClient):
    body = "This is an automated pull request generated by patched."
    pr = gh_client.create_pr(repo_slug, f"Patched results for branch: {original_branch_name}",
                             body, original_branch_name, next_branch_name)

    # reset prs by clearing previous comments
    for comment in pr.get_review_comments():
        comment.delete()

    comment_md_links = []
    for patch_msg, comment_kwargs in create_comments(applied_patches, diff_text, path):
        gh_comment = gh_client.create_comment(pr, comment_kwargs)
        comment_md_links.append(f"[{patch_msg.title}]({gh_comment.html_url})")

    body_items = []
    for comment_md_link in comment_md_links:
        body_items.append(f" *  {comment_md_link}")
    new_body = "\n".join([body, "------", *body_items])
    pr.edit(body=new_body)

    return pr.html_url


def create_comment(patch_message: PatchMessage, hunks: List[List[Line]]) -> Dict | None:
    if len(hunks) < 1:
        return None
    elif len(hunks) == 1 and len(hunks[0]) == 1:
        start_line = None
        end_line = hunks[0][0]
    else:
        start_line = end_line = None
        for lines in hunks:
            for line in lines:
                if line.source_line_no is None:
                    continue
                if patch_message.start_line <= line.source_line_no <= patch_message.end_line:
                    if start_line is None:
                        start_line = line
                    end_line = line

                if start_line is end_line:
                    start_line = None

    if end_line is None:
        return None

    start_side = None
    start_line_no = None
    # TODO: All can be LEFT side and source line if current is satisfactory
    if start_line is not None:
        start_side = "RIGHT" if start_line.is_added else "LEFT"
        start_line_no = start_line.target_line_no if start_line.is_added else start_line.source_line_no

    end_side = "RIGHT" if end_line.is_added else "LEFT"
    end_line_no = end_line.target_line_no if end_line.is_added else end_line.source_line_no

    body = f"""
{patch_message.title}
------
{patch_message.msg}
"""
    rv = {"body": body,
          "start_line": start_line_no,
          "start_side": start_side,
          "line": end_line_no,
          "side": end_side}
    return wipe_null(rv)


def create_comments(applied_patches: List[Patch], diff_text: str, path: str
                    ) -> Generator[tuple[PatchMessage, dict], None, None]:
    diffs = PatchSet(diff_text)
    diff_lines: Dict[str, Line] = {
        diff.path: [[line for line in hunk] for hunk in diff] for diff in diffs}
    for applied_patch in applied_patches:
        git_file_path = applied_patch.path.removeprefix(path + "/")
        hunks: List[List[Line]] = diff_lines.get(git_file_path, [])
        for patch_message in applied_patch.msgs:
            yv = create_comment(patch_message, hunks)
            if yv is None:
                continue
            yv["path"] = git_file_path
            yield patch_message, yv


def wipe_null(obj: dict):
    rv = dict()
    for key, value in obj.items():
        if value is not None:
            rv[key] = value
    return rv
